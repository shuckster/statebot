/*
 * Statebot
 * v2.4.0
 * https://shuckster.github.io/statebot/
 * License: ISC
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=(t=require("events"))&&"object"==typeof t&&"default"in t?t.default:t;function n(t){return Array.isArray(t)}function r(t){return"function"==typeof t}function o(t){return"string"==typeof t}function i(t){return"object"==typeof t}function s(t){return!(null===t||!i(t))&&Object.getPrototypeOf(t)===Object.prototype}function c(t){return!!o(t)||!!n(t)&&t.every(t=>o(t))}function a(t){return t.reduce((t,e)=>-1===t.indexOf(e)?[...t,e]:t,[])}function u(t){return(...e)=>(function(t,...e){const n=setTimeout(t,0,...e);return()=>{clearTimeout(n)}})(t,...e)}function f(t){let e,n=!1;return{fn:(...r)=>(n||(e=t(...r)),e),revoke:()=>{n=!0}}}function l(t,e,n,...r){const o={};function i(t){const e=s(t)-1;o[t]=Math.max(e,0)}function s(t){return o[t]||0}return[...r].flat().forEach(t=>{o[t]=0}),{increase:function(t){return o[t]=s(t)+1,()=>i(t)},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${n}:`,table:Object.keys(o).sort().map(t=>[t,o[t]]).map(([t,n])=>({[e]:t,refs:n||"None"}))}},refs:function(){return{...o}}}}function p(t=""){return function(e,n,...o){const i=Object.entries(n).map(([t,e])=>({argName:t,argType:e})),s=Object.keys(n).join(", "),c=o.map((t,e)=>{const{argName:n,argType:o}=i[e];if(void 0===t)return`Argument undefined: "${n}"`;let s,c,a;return r(o)?(a=!0===o(t),c=o.name,s=`${c}(${n}) did not return true`):(a=typeof t===o,c=o,s=`Argument "${n}" should be a ${c}`),a?void 0:`${s}: ${n} === ${typeof t}(${t})`}).filter(Boolean);return c.length?`\n${t}${e}(${s}):\n`+c.map(t=>"> "+t).join("\n"):void 0}}function h(t){let e=t;function n(){return e>=1}function r(){return e>=2}function i(){return e>=3}return o(e)&&(e={info:3,log:2,warn:1,none:0}[e]||3),{canWarn:n,canLog:r,canInfo:i,info:(...t)=>i()&&console.info(...t),table:(...t)=>r()&&console.table(...t),log:(...t)=>r()&&console.log(...t),warn:(...t)=>n()&&console.warn(...t),error:(...t)=>console.error(...t)}}const d=/[\r\n]/,m="|",g="->",$=[m,g].map(t=>t.replace("|","\\|")).join("|"),E=new RegExp(`(${$})$`),w=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,T=/(\/\/[^\n\r]*)/,v=p("statebot.");function S(t){const e=v("decomposeRoute",{templateLiteral:c},t);if(e)throw TypeError(e);return O(y(t)).flat(2)}function b(t){const e=v("decomposeChart",{chart:c},t);if(e)throw TypeError(e);const n=O(y(t)),r=n.map(x).flat(1).map(j).flat(1);let o=!1;const i=a(r.map(t=>(t.includes("")&&(o=!0),t.join(g)))),s=a(n.flat(3));return{transitions:i.map(t=>t.split(g)),routes:i,states:o?s:s.filter(Boolean)}}function y(t){const e=(function(t){return[t].flat().reduce((t,e)=>[...t,e.split(d)],[]).flat()})(t),n=[];let r=!1;const o=e.reduce((t,e)=>{const o=e.replace(T,"").replace(w,"");return o?(r=E.test(o),r?t+o:(n.push(t+o),"")):t},"");return r||o?[...n,o]:[...n]}function O(t){return t.map(t=>t.split(g).map(t=>t.split(m)))}function x(t){const e=[];return t.reduce((t,n)=>(!1===t||e.push([t,[...n]]),[...n]),!1),e}function j([t,e]){return t.reduce((t,n)=>[...t,...e.map(t=>[n,t])],[])}function A(t,e){const n=[],r=[];return{configs:t.reduce((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=b(i);return e()&&(n.push(...c),r.push(...a)),[...t,...u.map(t=>{const[e,n]=t;return{fromState:e,toState:n,action:s}})]},[]),states:n,routes:r}}function I(t){return s(t)&&"number"==typeof t.__STATEBOT__}const L=p("statebot.");let N=0;function P(){const t=Date.now();function e(t,e){return t.toFixed(e).replace(/\.0+$/,"")}return function(){const n=Date.now()-t;return n<500?e(n)+" ms":n<5e3?e(n/1e3,2)+" s ":n<6e4?e(n/1e3,1)+" s ":e(n/1e3/60,1)+" m "}}exports.Statebot=function(t,c){if(!o(t))throw TypeError("\nStatebot: Please specify a name for this machine");const a=`Statebot[${t}]`;if(!s(c))throw TypeError(`\n${a}: Please specify options for this machine`);const{chart:u,logLevel:f=3,historyLimit:d=2}=c||{},m=p(a+"#"),$=h(f),{canWarn:E}=$,{states:w=[],routes:T=[]}=u?b(u):c,{startIn:v=w[0]}=c;if(!w.includes(v))throw Error(`${a}: Starting-state not in chart: "${v}"`);let S=0;const y=[v],O=Math.max(d,2),x=i(j=c.events)&&r(j.emit)&&r(j.addListener)&&r(j.removeListener)?c.events:new e;var j;const I=new e,L={onSwitching:"(ANY)state:changing",onSwitched:"(ANY)state:changed"},{pause:N,resume:P,paused:_,Pausable:k}=(function(t=!1,e=(()=>{})){let n=!!t;return{Pausable:function(t){return(...r)=>n?(e(),!1):t(...r)},paused:()=>n,pause:()=>{n=!0},resume:()=>{n=!1}}})(!1,()=>{$.warn(a+": Ignoring callback, paused")}),R=k((t,...e)=>I.emit(t,...e));function C(t,e){return I.addListener(t,e),()=>{I.removeListener(t,e)}}const D=l(t,"states","Listening for the following state-changes",[...w]),M=l(t,"transitions","Listening for the following transitions",[...T]),F=l(t,"events","Listening for the following events");function B(e,i){const c=r(e)?e({enter:W,emit:V,Enter:Q,Emit:J}):s(e)?e:null;if(!s(c))throw TypeError(`Statebot[${t}]#${i}(): Expected an object, or a function that returns an object`);const a={},u=[];Object.entries(c).forEach(([t,e])=>{if(r(e))u.push({routeChart:t,action:e});else if(!s(e))return;const{on:i,then:c}=e;if(o(i)||n(i)){[i].flat().forEach(e=>{a[e]=a[e]||[],a[e].push({routeChart:t,action:c})})}else r(c)&&u.push({routeChart:t,action:e})});const f=[],l=[],p=[],h=Object.entries(a).reduce((t,[e,n])=>{const{states:r,routes:o,configs:i}=A(n,E);return E()&&(f.push(...r),l.push(...o)),{...t,[e]:i}},{});p.push(...Object.entries(h).map(([t,e])=>[F.increase(t),q(t,(...n)=>{e.some(({fromState:t,toState:e,action:o})=>!!U(t,()=>(W(e,...n),r(o)&&o(...n),!0)))||X(`Event not handled: "${t}"`)})]).flat());const d=A(u,E);if(E()&&(f.push(...d.states),l.push(...d.routes)),p.push(...d.configs.map(t=>{const{fromState:e,toState:n,action:r}=t,o=`${e}->${n}`;return[M.increase(o),C(o,r)]}).flat()),E()){const e=f.filter(t=>!w.includes(t)),n=l.filter(t=>!T.includes(t));e.length&&$.warn(`Statebot[${t}]#${i}(): Invalid states specified:\n`+e.map(t=>`  > "${t}"`).join("\n")),n.length&&$.warn(`Statebot[${t}]#${i}(): Invalid transitions specified:\n`+n.map(t=>`  > "${t}"`).join("\n"))}return()=>p.forEach(t=>t())}function Y(){return y[y.length-2]}function G(){return y[y.length-1]}function H(t){const e=void 0!==t?t:G(),n=m("statesAvailableFromHere",{state:o},e);if(n)throw TypeError(n);return T.reduce((t,n)=>{const[r,o]=n.split(g).map(t=>t.trim());return r===e?[...t,o]:t},[])}function U(t,e,...n){const i=m("inState",{state:o},t);if(i)throw TypeError(i);const s=G()===t;return void 0!==e?s?r(e)?e(...n):e:null:s}const V=k((t,...e)=>{const n=m("emit",{eventName:o},t);if(n)throw TypeError(n);return x.emit(t,...e)}),W=k((t,...e)=>{const n=m("enter",{state:o},t);if(n)throw TypeError(n);const r=G(),i=t;if(i===r)return X(`Already in state: "${i}"`),!1;if(!w.includes(i))return X(`Invalid state "${i}", not switching`),!1;const s=`${r}->${i}`;return T.includes(s)?($.info(`${a}: tId<${++S}>: ${s}`),y.push(i),y.length>O&&y.shift(),R(L.onSwitching,i,r,...e),R(s,...e),R(L.onSwitched,i,r,...e),!0):(X(`Invalid transition "${s}", not switching`),!1)});function q(t,e){const n=m("onEvent",{eventName:o,cb:r},t,e);if(n)throw TypeError(n);return x.addListener(t,e),()=>x.removeListener(t,e)}const z=Object.keys(L).reduce((t,e)=>({...t,[e]:function(t){const n=m(e,{cb:r},t);if(n)throw TypeError(n);const o=D.increase(L[e]),i=C(L[e],t);return()=>{i(),o()}}}),{}),K=[["Exiting","onSwitching"],["Entering","onSwitching"],["Exited","onSwitched"],["Entered","onSwitched"]].reduce((t,e)=>{const[n,i]=e,s="on"+n,c=n.toLowerCase();return{...t,[s]:function(t,e){const a=m(s,{state:o,cb:r},t,e);if(a)throw TypeError(a);const u=[D.increase(t),D.increase(`${t}:${c}`)],f=z[i]((r,o,...i)=>{0===n.indexOf("Exit")?t===o&&e(r,...i):t===r&&e(o,...i)});return()=>{f(),u.map(t=>t())}}}},{});function J(t,...e){const n=m("Emit",{eventName:o},t);if(n)throw TypeError(n);return(...n)=>V(t,...e,...n)}function Q(t,...e){const n=m("Enter",{state:o},t);if(n)throw TypeError(n);return(...n)=>W(t,...e,...n)}function X(t){const e=Y(),n=G(),r=`${void 0===e?"[undefined]":e}->${n}`,o=H();o.length?$.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > From "${n}", valid states are: [${o.map(t=>`"${t}"`).join(", ")}]`):$.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${n}"`)}function Z(t){const{description:e,table:n}=t.toValue();$.log(e),n.length?$.table(n):$.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const e=t.flat(),n=m("canTransitionTo",{state:o},e[0]);if(n)throw TypeError(n);if(!e.length)return!1;const r=H();return e.every(t=>r.includes(t))},currentState:G,emit:V,Emit:J,enter:W,Enter:Q,history:()=>[...y],info:()=>($.log(a+": Information about this state-machine"),Z(D),Z(M),void Z(F)),inspect:()=>({states:D.refs(),transitions:M.refs(),events:F.refs()}),inState:U,InState:function(t,e,...n){const r=m("InState",{state:o},t);if(r)throw TypeError(r);return(...r)=>U(t,e,...n,...r)},name:()=>t,onEntered:K.onEntered,onEntering:K.onEntering,onEvent:q,onExited:K.onExited,onExiting:K.onExiting,onSwitched:z.onSwitched,onSwitching:z.onSwitching,onTransitions:t=>B(t,"onTransitions"),pause:N,paused:_,performTransitions:t=>B(t,"performTransitions"),previousState:Y,reset:function(){$.warn(a+": State-machine reset!"),y.length=0,y.push(v)},resume:P,statesAvailableFromHere:H}},exports.assertRoute=function(t,e,n){const r=L("assertRoute",{machine:I,expectedRoute:c},t,e);if(r)throw TypeError(r);N+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:a=0,timeoutInMs:l=1e3,logLevel:p=3}=n||{},d=h(p),m=`Statebot[${t.name()}]: aId<${N}>`,g=S(e);d.log(`\n${m}: Asserting route: [${g.join(" > ")}]`),d.log(`${m}: > Assertion will start from state: "${i}"`);const $=u(s);let E=()=>{};const w=P();let T,v=P(),b=0,y=!0,O=!1;const x=[...g],j=(function(t=[],e=[]){const n=[],r=t.map((t,n)=>e[n]||"center");let o=!1;return{lock:function(){o=!0},addRow:function(...e){if(o)return;const r=t.reduce((t,n,r)=>({...t,[n]:e[r]||""}),{});n.push(r)},content:function(){const e=n.reduce((e,n)=>t.map((t,r)=>Math.max(n[t].length,e[r])),t.map(()=>0));function o(t,n){const o=e[n],i=r[n];return"left"===i?(s=t)+" ".repeat(o-s.length):"right"===i?(function(t,e){return" ".repeat(e-t.length)+t})(t,o):t;var s}return n.reduce((e,n)=>[...e,t.reduce((t,e,r)=>({...t,[e]:o(n[e],r)}),{})],[])}}})(["state","expected","info","took"],["center","center","left","right"]),A=(function(t){const{revoke:e,fn:n}=f(t);let r;return function(...t){return r=n(...t),e(),r}})(t=>(_("","","","TOTAL: "+w()),j.lock(),d.log(`\n${m}: ${o}: [${t?"FAILED":"SUCCESS"}]`),d.table(j.content()),t)),{addRow:_}=j;return new Promise((e,n)=>{if(0===x.length)return void n(A(new Error("NO ROUTE TO TEST")));const r=e=>{for(;x.length;){const n=x.shift();_(t.currentState(),`(${n})`,e),O=!1}(t=>{clearTimeout(T),E(),c(),n(t)})(A(new Error(e)))};t.inState(i)&&(y=!1,E=$());const{revoke:o,fn:s}=f(t=>{T=setTimeout(()=>{o(),r("TIMEOUT")},l),(function(t){if(y)_(t,"-","PENDING");else{const e=x[0];e===t?(_(t,e,O?"REALIGNED":"OKAY",v()),O=!1,x.shift()):(_(t,e,"WRONG STATE",v()),O=!0,b+=1),v=P()}})(t),y&&t===i&&(y=!1,E=$()),b>a&&(o(),r("TOO MANY DEVIATIONS")),x.length<=0&&(o(),((...t)=>{clearTimeout(T),E(),c(),e(...t)})(A()))}),c=t.onSwitching(s)})},exports.decomposeChart=b,exports.isStatebot=I,exports.routeIsPossible=function(t,e){const n=L("routeIsPossible",{machine:I,route:c},t,e);if(n)throw TypeError(n);const r=S(e);return r.every((e,n)=>{if(n===r.length-1)return!0;{const o=r[n+1];return t.statesAvailableFromHere(e).includes(o)}})};
