/*
 * Statebot
 * v2.3.6
 * https://shuckster.github.io/statebot/
 * License: ISC
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,n=(t=require("events"))&&"object"==typeof t&&"default"in t?t.default:t;function e(t){return Array.isArray(t)}function r(t){return"function"==typeof t}function o(t){return"string"==typeof t}function i(t){return"object"==typeof t}function s(t){return!(null===t||!i(t))&&Object.getPrototypeOf(t)===Object.prototype}function c(t){return!!o(t)||!!e(t)&&t.every(t=>o(t))}function a(t){return t.reduce((t,n)=>-1===t.indexOf(n)?[...t,n]:t,[])}function u(t){return(...n)=>(function(t,...n){const e=setTimeout(t,0,...n);return()=>{clearTimeout(e)}})(t,...n)}function f(t){let n,e=!1;return{fn:(...r)=>(e||(n=t(...r)),n),revoke:()=>{e=!0}}}function l(t,n,e,...r){const o={};function i(t){const n=s(t)-1;o[t]=Math.max(n,0)}function s(t){return o[t]||0}return[...r].flat().forEach(t=>{o[t]=0}),{increase:function(t){return o[t]=s(t)+1,()=>i(t)},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${e}:`,table:Object.keys(o).sort().map(t=>[t,o[t]]).map(([t,e])=>({[n]:t,refs:e||"None"}))}},refs:function(){return{...o}}}}function h(t=""){return function(n,e,...o){const i=Object.entries(e).map(([t,n])=>({argName:t,argType:n})),s=Object.keys(e).join(", "),c=o.map((t,n)=>{const{argName:e,argType:o}=i[n];if(void 0===t)return`Argument undefined: "${e}"`;let s,c,a;return r(o)?(a=!0===o(t),c=o.name,s=`${c}(${e}) did not return true`):(a=typeof t===o,c=o,s=`Argument "${e}" should be a ${c}`),a?void 0:`${s}: ${e} === ${typeof t}(${t})`}).filter(Boolean);return c.length?`\n${t}${n}(${s}):\n`+c.map(t=>"> "+t).join("\n"):void 0}}function p(t){let n=t;function e(){return n>=1}function r(){return n>=2}function i(){return n>=3}return o(n)&&(n={info:3,log:2,warn:1,none:0}[n]||3),{canWarn:e,canLog:r,canInfo:i,info:(...t)=>i()&&console.info(...t),table:(...t)=>r()&&console.table(...t),log:(...t)=>r()&&console.log(...t),warn:(...t)=>e()&&console.warn(...t),error:(...t)=>console.error(...t)}}const d=/[\r\n]/,m="|",g="->",$=[m,g].map(t=>t.replace("|","\\|")).join("|"),E=new RegExp(`(${$})$`),w=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,T=/(\/\/[^\n\r]*)/,v=h("statebot.");function S(t){const n=v("decomposeRoute",{templateLiteral:c},t);if(n)throw TypeError(n);return O(y(t)).flat(2)}function b(t){const n=v("decomposeChart",{chart:c},t);if(n)throw TypeError(n);const e=O(y(t)).map(x).flat(1).map(j).flat(1),r=[],o=a(e.map(t=>(r.push(...t),t.join(g)))),i=a(r);return{transitions:o.map(t=>t.split(g)),routes:o,states:i}}function y(t){const n=(function(t){return[t].flat().reduce((t,n)=>[...t,n.split(d)],[]).flat()})(t),e=[];return n.reduce((t,n)=>{const r=n.replace(T,"").replace(w,"");return r?E.test(r)?t+r:(e.push(t+r),""):t},""),e}function O(t){return t.map(t=>t.split(g).map(t=>t.split(m)))}function x(t){const n=[];return t.reduce((t,e)=>(!1===t||n.push([t,[...e]]),[...e]),!1),n}function j([t,n]){return t.reduce((t,e)=>[...t,...n.map(t=>[e,t])],[])}function A(t,n){const e=[],r=[];return{configs:t.reduce((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=b(i);return n()&&(e.push(...c),r.push(...a)),[...t,...u.map(t=>{const[n,e]=t;return{fromState:n,toState:e,action:s}})]},[]),states:e,routes:r}}function I(t){return s(t)&&"number"==typeof t.__STATEBOT__}const L=h("statebot.");let N=0;function _(){const t=Date.now();function n(t,n){return t.toFixed(n).replace(/\.0+$/,"")}return function(){const e=Date.now()-t;return e<500?n(e)+" ms":e<5e3?n(e/1e3,2)+" s ":e<6e4?n(e/1e3,1)+" s ":n(e/1e3/60,1)+" m "}}exports.Statebot=function(t,c){if(!o(t))throw TypeError("\nStatebot: Please specify a name for this machine");const a=`Statebot[${t}]`;if(!s(c))throw TypeError(`\n${a}: Please specify options for this machine`);const{chart:u,logLevel:f=3,historyLimit:d=2}=c||{},m=h(a+"#"),$=p(f),{canWarn:E}=$,{states:w=[],routes:T=[]}=u?b(u):c,{startIn:v=w[0]}=c;if(!w.includes(v))throw Error(`${a}: Starting-state not in chart: "${v}"`);let S=0;const y=[v],O=Math.max(d,2),x=i(j=c.events)&&r(j.emit)&&r(j.addListener)&&r(j.removeListener)?c.events:new n;var j;const I=new n,L={onSwitching:"(ANY)state:changing",onSwitched:"(ANY)state:changed"};function N(t,...n){return I.emit(t,...n)}function _(t,n){return I.addListener(t,n),function(){I.removeListener(t,n)}}const P=l(t,"states","Listening for the following state-changes",[...w]),R=l(t,"transitions","Listening for the following transitions",[...T]),k=l(t,"events","Listening for the following events");function C(n,i){const c=r(n)?n({enter:G,emit:B,Enter:q,Emit:W}):s(n)?n:null;if(!s(c))throw TypeError(`Statebot[${t}]#${i}(): Expected an object, or a function that returns an object`);const a={},u=[];Object.entries(c).forEach(([t,n])=>{if(r(n))u.push({routeChart:t,action:n});else if(!s(n))return;const{on:i,then:c}=n;if(o(i)||e(i)){[i].flat().forEach(n=>{a[n]=a[n]||[],a[n].push({routeChart:t,action:c})})}else r(c)&&u.push({routeChart:t,action:n})});const f=[],l=[],h=Object.entries(a).reduce((t,[n,e])=>{const{states:r,routes:o,configs:i}=A(e,E);return E()&&(f.push(...r),l.push(...o)),{...t,[n]:i}},{}),p=[];p.push(...Object.entries(h).map(([t,n])=>[k.increase(t),H(t,(...e)=>{n.some(({fromState:t,toState:n,action:o})=>!!Y(t,()=>(G(n,...e),r(o)&&o(...e),!0)))||z(`Event not handled: "${t}"`)})]).flat());const d=A(u,E);if(E()&&(f.push(...d.states),l.push(...d.routes)),p.push(...d.configs.map(t=>{const{fromState:n,toState:e,action:r}=t,o=`${n}->${e}`;return[R.increase(o),_(o,r)]}).flat()),E()){const n=f.filter(t=>!w.includes(t)),e=l.filter(t=>!T.includes(t));n.length&&$.warn(`Statebot[${t}]#${i}(): Invalid states specified:\n`+n.map(t=>`  > "${t}"`).join("\n")),e.length&&$.warn(`Statebot[${t}]#${i}(): Invalid transitions specified:\n`+e.map(t=>`  > "${t}"`).join("\n"))}return()=>p.forEach(t=>t())}function D(){return y[y.length-2]}function M(){return y[y.length-1]}function F(t){const n=void 0!==t?t:M(),e=m("statesAvailableFromHere",{state:o},n);if(e)throw TypeError(e);return T.reduce((t,e)=>{const[r,o]=e.split(g).map(t=>t.trim());return r===n?[...t,o]:t},[])}function Y(t,n,...e){const i=m("inState",{state:o},t);if(i)throw TypeError(i);const s=M()===t;return void 0!==n?s?r(n)?n(...e):n:null:s}function B(t,...n){const e=m("emit",{eventName:o},t);if(e)throw TypeError(e);return x.emit(t,...n)}function G(t,...n){const e=m("enter",{state:o},t);if(e)throw TypeError(e);const r=M(),i=t;if(i===r)return z(`Already in state: "${i}"`),!1;if(!w.includes(i))return z(`Invalid state "${i}", not switching`),!1;const s=`${r}->${i}`;return T.includes(s)?($.info(`${a}: tId<${++S}>: ${s}`),y.push(i),y.length>O&&y.shift(),N(L.onSwitching,i,r,...n),N(s,...n),N(L.onSwitched,i,r,...n),!0):(z(`Invalid transition "${s}", not switching`),!1)}function H(t,n){const e=m("onEvent",{eventName:o,cb:r},t,n);if(e)throw TypeError(e);return x.addListener(t,n),()=>x.removeListener(t,n)}const U=Object.keys(L).reduce((t,n)=>({...t,[n]:function(t){const e=m(n,{cb:r},t);if(e)throw TypeError(e);const o=P.increase(L[n]),i=_(L[n],(n,e,...r)=>{t(n,e,...r)});return()=>{i(),o()}}}),{}),V=[["Exiting","onSwitching"],["Entering","onSwitching"],["Exited","onSwitched"],["Entered","onSwitched"]].reduce((t,n)=>{const[e,i]=n,s="on"+e,c=e.toLowerCase();return{...t,[s]:function(t,n){const a=m(s,{state:o,cb:r},t,n);if(a)throw TypeError(a);const u=[P.increase(t),P.increase(`${t}:${c}`)],f=U[i]((r,o,...i)=>{0===e.indexOf("Exit")?t===o&&n(r,...i):t===r&&n(o,...i)});return()=>{f(),u.map(t=>t())}}}},{});function W(t,...n){const e=m("Emit",{eventName:o},t);if(e)throw TypeError(e);return(...e)=>B(t,...n,...e)}function q(t,...n){const e=m("Enter",{state:o},t);if(e)throw TypeError(e);return(...e)=>G(t,...n,...e)}function z(t){const n=D(),e=M(),r=`${void 0===n?"[undefined]":n}->${e}`,o=F();o.length?$.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > From "${e}", valid states are: [${o.map(t=>`"${t}"`).join(", ")}]`):$.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${e}"`)}function K(t){const{description:n,table:e}=t.toValue();$.log(n),e.length?$.table(e):$.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const n=t.flat(),e=m("canTransitionTo",{state:o},n[0]);if(e)throw TypeError(e);if(!n.length)return!1;const r=F();return n.every(t=>r.includes(t))},currentState:M,emit:B,Emit:W,enter:G,Enter:q,history:()=>[...y],info:()=>($.log(a+": Information about this state-machine"),K(P),K(R),void K(k)),inspect:()=>({states:P.refs(),transitions:R.refs(),events:k.refs()}),inState:Y,InState:function(t,n,...e){const r=m("InState",{state:o},t);if(r)throw TypeError(r);return(...r)=>Y(t,n,...e,...r)},name:()=>t,onEntered:V.onEntered,onEntering:V.onEntering,onEvent:H,onExited:V.onExited,onExiting:V.onExiting,onSwitched:U.onSwitched,onSwitching:U.onSwitching,onTransitions:t=>C(t,"onTransitions"),performTransitions:t=>C(t,"performTransitions"),previousState:D,reset:function(){$.warn(a+": State-machine reset!"),y.length=0,y.push(v)},statesAvailableFromHere:F}},exports.assertRoute=function(t,n,e){const r=L("assertRoute",{machine:I,expectedRoute:c},t,n);if(r)throw TypeError(r);N+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:a=0,timeoutInMs:l=1e3,logLevel:h=3}=e||{},d=p(h),m=`Statebot[${t.name()}]: aId<${N}>`,g=S(n);d.log(`\n${m}: Asserting route: [${g.join(" > ")}]`),d.log(`${m}: > Assertion will start from state: "${i}"`);const $=u(s);let E=()=>{};const w=_();let T,v=_(),b=0,y=!0,O=!1;const x=[...g],j=(function(t=[],n=[]){const e=[],r=t.map((t,e)=>n[e]||"center");let o=!1;return{lock:function(){o=!0},addRow:function(...n){if(o)return;const r=t.reduce((t,e,r)=>({...t,[e]:n[r]||""}),{});e.push(r)},content:function(){const n=e.reduce((n,e)=>t.map((t,r)=>Math.max(e[t].length,n[r])),t.map(()=>0));function o(t,e){const o=n[e],i=r[e];return"left"===i?(s=t)+" ".repeat(o-s.length):"right"===i?(function(t,n){return" ".repeat(n-t.length)+t})(t,o):t;var s}return e.reduce((n,e)=>[...n,t.reduce((t,n,r)=>({...t,[n]:o(e[n],r)}),{})],[])}}})(["state","expected","info","took"],["center","center","left","right"]),A=(function(t){const{revoke:n,fn:e}=f(t);let r;return function(...t){return r=e(...t),n(),r}})(t=>(P("","","","TOTAL: "+w()),j.lock(),d.log(`\n${m}: ${o}: [${t?"FAILED":"SUCCESS"}]`),d.table(j.content()),t)),{addRow:P}=j;return new Promise((n,e)=>{if(0===x.length)return void e(A(new Error("NO ROUTE TO TEST")));const r=n=>{for(;x.length;){const e=x.shift();P(t.currentState(),`(${e})`,n),O=!1}(t=>{clearTimeout(T),E(),c(),e(t)})(A(new Error(n)))};t.inState(i)&&(y=!1,E=$());const{revoke:o,fn:s}=f(t=>{T=setTimeout(()=>{o(),r("TIMEOUT")},l),(function(t){if(y)P(t,"-","PENDING");else{const n=x[0];n===t?(P(t,n,O?"REALIGNED":"OKAY",v()),O=!1,x.shift()):(P(t,n,"WRONG STATE",v()),O=!0,b+=1),v=_()}})(t),y&&t===i&&(y=!1,E=$()),b>a&&(o(),r("TOO MANY DEVIATIONS")),x.length<=0&&(o(),((...t)=>{clearTimeout(T),E(),c(),n(...t)})(A()))}),c=t.onSwitching(s)})},exports.decomposeChart=b,exports.isStatebot=I,exports.routeIsPossible=function(t,n){const e=L("routeIsPossible",{machine:I,route:c},t,n);if(e)throw TypeError(e);const r=S(n);return r.every((n,e)=>{if(e===r.length-1)return!0;{const o=r[e+1];return t.statesAvailableFromHere(n).includes(o)}})};
