/*
 * Statebot
 * v2.8.1
 * https://shuckster.github.io/statebot/
 * License: MIT
 */
"use strict";function t(t){return{all:t=t||new Map,on:function(n,e){var r=t.get(n);r?r.push(e):t.set(n,[e])},off:function(n,e){var r=t.get(n);r&&(e?r.splice(r.indexOf(e)>>>0,1):t.set(n,[]))},emit:function(n,e){var r=t.get(n);r&&r.slice().map((function(t){t(e)})),(r=t.get("*"))&&r.slice().map((function(t){t(n,e)}))}}}function n(t){return Array.isArray(t)}function e(t){return"function"==typeof t}function r(t){return"string"==typeof t}function o(t){return"object"==typeof t}function i(t){return!(null===t||!o(t))&&Object.getPrototypeOf(t)===Object.prototype}function s(t){return!!r(t)||!!n(t)&&t.every(r)}Object.defineProperty(exports,"__esModule",{value:!0});function c(t){return function(n,o,...i){const s=Object.entries(o).map((([t,n])=>({argName:t,argType:n}))),c=i.map(((...t)=>((t,n,o)=>{const{argName:i,argType:s}=t[o];if(void 0===n)return`Argument undefined: "${i}"`;const c=Array.isArray(s)?s:[s],a=c.map((t=>e(t)?((t,n,e)=>n(e)?void 0:`${n.name}(${t}) did not return true`)(i,t,n):((t,n,e)=>typeof e===n?void 0:`Argument "${t}" should be a ${n}`)(i,t,n))).filter(r);return(c.length>1?a.length>1:a.length)?`${a.join("\n| ")}\n> typeof ${i} === ${typeof n}(${JSON.stringify(n)})`:void 0})(s,...t))).filter(r);if(!c.length)return;const a=Object.keys(o).join(", ");return`\n${t||""}${n}(${a}):\n${c.map((t=>`| ${t}`)).join("\n")}`}}function a(t){const n=t.addListener?(...n)=>t.addListener(...n):(...n)=>t.on(...n),e=t.removeListener?(...n)=>t.removeListener(...n):(...n)=>t.off(...n),r=new Map;return{emit:(n,...e)=>t.emit(n,e),on:function(t,e){let o=r.get(e);o||(o={handleEvent:(t=[])=>e(...[t].flat()),refCount:0},r.set(e,o)),o.refCount+=1,n(t,o.handleEvent)},off:function(t,n){let o=r.get(n);o&&(e(t,o.handleEvent),o.refCount-=1,0===o.refCount&&r.delete(n))}}}function u(t){return t.reduce(((t,n)=>-1===t.indexOf(n)?[...t,n]:t),[])}function f(t){return(...n)=>(function(t,...n){const e=setTimeout(t,0,...n);return()=>{clearTimeout(e)}})(t,...n)}function l(t){const{revoke:n,fn:e}=p(t);let r;return function(...t){return r=e(...t),n(),r}}function p(t){let n,e=!1;return{fn:(...r)=>(e||(n=t(...r)),n),revoke:()=>{e=!0}}}function h(t,n,e,...r){const o=[...r].flat().reduce(((t,n)=>({...t,[n]:0})),{});function i(t){const n=s(t)-1;o[t]=Math.max(n,0)}function s(t){return o[t]||0}return{increase:function(t){return o[t]=s(t)+1,()=>{i(t)}},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${e}:`,table:Object.keys(o).sort().map((t=>[t,o[t]])).map((([t,e])=>({[n]:t,refs:e||"None"})))}},refs:function(){return{...o}}}}function d(t,n){function e(){return t>=1}function o(){return t>=2}function i(){return t>=3}r(t)&&(t={info:3,log:2,warn:1,none:0}[t]||3);const{info:s,table:c,log:a,warn:u,error:f}=n||console;return{canWarn:e,canLog:o,canInfo:i,info:(...t)=>{i()&&s(...t)},table:(...t)=>{o()&&c(...t)},log:(...t)=>{o()&&a(...t)},warn:(...t)=>{e()&&u(...t)},error:(...t)=>{f(...t)}}}const m=/[\r\n]/,g="|",$="->",w=[g,$].map((t=>t.replace("|","\\|"))).join("|"),v=new RegExp(`(${w})$`),E=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,T=/(\/\/[^\n\r]*)/,y=c("statebot.");function b(t){const n=y("decomposeRoute",{templateLiteral:s},t);if(n)throw TypeError(n);return A(O(t)).flat(2)}function S(t){const n=y("decomposeChart",{chart:s},t);if(n)throw TypeError(n);const e=A(O(t)),r=e.flatMap(j).flatMap(x);let o=!1;const i=u(r.map((t=>(t.includes("")&&(o=!0),t.join($))))),c=u(e.flat(3));return{transitions:i.map((t=>t.split($))),routes:i,states:o?c:c.filter(Boolean)}}function O(t){const n=(function(t){return[t].flat().reduce(((t,n)=>[...t,...n.split(m)]),[])})(t),e=[];let r=!1;const o=n.reduce(((t,n)=>{const o=n.replace(T,"").replace(E,"");return o?(r=v.test(o),r?t+o:(e.push(t+o),"")):t}),"");return r||o?[...e,o]:[...e]}function A(t){return t.map((t=>t.split($).map((t=>t.split(g)))))}function j(t){const n=[];return t.reduce(((t,e)=>(!1===t||n.push([t,[...e]]),[...e])),!1),n}function x([t,n]){return t.reduce(((t,e)=>[...t,...n.map((t=>[e,t]))]),[])}const I="onExiting",L="onEntering",N="onExited",C="onEntered",P="onSwitching",M="onSwitched",_={[P]:"(ANY)state:changing",[M]:"(ANY)state:changed"};function k(t,n){const e=[],r=[];return{configs:t.reduce(((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=S(i);return n()&&(e.push(...c),r.push(...a)),[...t,...u.map((([t,n])=>({fromState:t,toState:n,action:s})))]}),[]),states:e,routes:r}}function R(t){return i(t)&&"number"==typeof t.__STATEBOT__}const D=c("statebot.");let F=0;function Y(){const t=Date.now();function n(t,n){return t.toFixed(n).replace(/\.0+$/,"")}return function(){const e=Date.now()-t;return e<500?`${n(e)} ms`:e<5e3?`${n(e/1e3,2)} s `:e<6e4?`${n(e/1e3,1)} s `:`${n(e/1e3/60,1)} m `}}exports.Statebot=function(s,u){if(!r(s))throw new TypeError("\nStatebot: Please specify a name for this machine");const f=`Statebot[${s}]`;if(!i(u))throw new TypeError(`\n${f}: Please specify options for this machine`);const{chart:p,logLevel:m=3,historyLimit:g=2}=u||{},w=void 0===u.events?a(t()):o(v=u.events)&&e(v.emit)&&(e(v.addListener)||e(v.on))&&(e(v.removeListener)||e(v.off))&&a(u.events);var v;if(!w)throw new TypeError(`\n${f}: Invalid event-emitter specified in options`);const{states:E=[],routes:T=[]}=p?S(p):u,{startIn:y=E[0]}=u;if(!E.includes(y))throw new Error(`${f}: Starting-state not in chart: "${y}"`);const b=c(`${f}#`),O=d(m,console),{canWarn:A}=O,j=[y],x=Math.max(g,2);let R=0;const{pause:D,resume:F,paused:Y,Pausable:B}=(function(t,n){n=n||function(){};let e=!!t;return{Pausable:function(t){return(...r)=>e?(n(),!1):t(...r)},paused:()=>e,pause:()=>{e=!0},resume:()=>{e=!1}}})(!1,(()=>O.warn(`${f}: Ignoring callback, paused`))),G=a(t()),H=B(G.emit);function U(t,n){return G.on(t,n),()=>G.off(t,n)}const V=h(s,"states","Listening for the following state-changes",[...E]),W=h(s,"transitions","Listening for the following transitions",[...T]),z=h(s,"events","Listening for the following events");function J(t,o){const c=e(t)?t({enter:nt,emit:tt,Enter:st,Emit:it}):i(t)?t:null;if(!i(c))throw new TypeError(`Statebot[${s}]#${o}(): Expected an object, or a function that returns an object`);const a=[],u=[],{transitionsForEvents:f,transitionsOnly:p}=(function(t){const o={},s=[];return Object.entries(t).map((([t,c])=>{if(e(c))return void s.push({routeChart:t,action:c});if(!i(c))return;const{on:a,then:u}=c;if(r(a)||n(a)){[a].flat().map((n=>{o[n]=o[n]||[],o[n].push({routeChart:t,action:u})}))}else e(u)&&s.push({routeChart:t,action:c})})),{transitionsForEvents:o,transitionsOnly:s}})(c),h=Object.entries(f).reduce((function(t,[n,e]){const{states:r,routes:o,configs:i}=k(e,A);A()&&(a.push(...r),u.push(...o));return{...t,[n]:i}}),{}),d=k(p,A),m=Object.entries(h).map((function([t,n]){return[z.increase(t),et(t,((...e)=>{n.map((t=>({...t,args:e}))).some(g)||ct(`Event not handled: "${t}"`)}))]})).concat(d.configs.map((function(t){const{fromState:n,toState:e,action:r}=t,o=`${n}->${e}`;return[W.increase(o),U(o,(i=e,s=r,(...t)=>$(i,s,...t)))];var i,s}))).flat();if(A()){a.push(...d.states),u.push(...d.routes);const t=a.filter((t=>!E.includes(t))),n=u.filter((t=>!T.includes(t)));t.length&&O.warn(`Statebot[${s}]#${o}(): Invalid states specified:\n`+t.map((t=>`  > "${t}"`)).join("\n")),n.length&&O.warn(`Statebot[${s}]#${o}(): Invalid transitions specified:\n`+n.map((t=>`  > "${t}"`)).join("\n"))}return()=>m.map((t=>t()));function g({fromState:t,toState:n,action:r,args:o}){return Z(t,(()=>(nt(n,...o),e(r)&&$(n,r,...o),!0)))}function $(t,n,...r){const o=n(...r);if(e(o)){const n=l(ot[I](t,(t=>{n(),o(t)})));m.push(n)}}}function K(){return j[j.length-2]}function q(){return j[j.length-1]}function Q(t){const n=void 0!==t?t:q(),e=b("statesAvailableFromHere",{state:r},n);if(e)throw new TypeError(e);return T.reduce(((t,e)=>{const[r,o]=e.split($).map((t=>t.trim()));return r===n?[...t,o]:t}),[])}function X(t,n,...r){const o=q()===t;return void 0===n?o:o?e(n)?n(...r):n:null}function Z(...t){const n=b("inState",{state:[r,i]},t[0]);if(n)throw new TypeError(n);return i(t[0])?(function(t,...n){const e=Object.entries(t).find((([t])=>X(t)));return e?X(...e.concat(n)):null})(...t):X(...t)}const tt=B(((t,...n)=>{const e=b("emit",{eventName:r},t);if(e)throw new TypeError(e);return w.emit(t,...n)})),nt=B(((t,...n)=>{const e=b("enter",{state:r},t);if(e)throw new TypeError(e);const o=q(),i=t;if(i===o)return ct(`Already in state: "${i}"`),!1;if(!E.includes(i))return ct(`Invalid state "${i}", not switching`),!1;const s=`${o}->${i}`;return T.includes(s)?(O.info(`${f}: tId<${++R}>: ${s}`),j.push(i),j.length>x&&j.shift(),H(_[P],i,o,...n),H(s,...n),H(_[M],i,o,...n),!0):(ct(`Invalid transition "${s}", not switching`),!1)}));function et(t,n){const o=b("onEvent",{eventName:r,cb:e},t,n);if(o)throw new TypeError(o);return w.on(t,n),()=>w.off(t,n)}const rt=Object.keys(_).reduce(((t,n)=>({...t,[n]:t=>{const r=b(n,{cb:e},t);if(r)throw new TypeError(r);const o=V.increase(_[n]),i=U(_[n],t);return()=>{i(),o()}}})),{}),ot=[[I,P],[L,P],[N,M],[C,M]].reduce(((t,n)=>{const[o,i]=n,s=o.slice(2),c=s.toLowerCase();return{...t,[o]:(t,n)=>{const a=b(o,{state:r,cb:e},t,n);if(a)throw new TypeError(a);const u=[V.increase(t),V.increase(`${t}:${c}`)],f=rt[i](((e,r,...o)=>{0===s.indexOf("Exit")?t===r&&n(e,...o):t===e&&n(r,...o)}));return()=>{f(),u.map((t=>t()))}}}}),{});function it(t,...n){const e=b("Emit",{eventName:r},t);if(e)throw new TypeError(e);return(...e)=>tt(t,...n,...e)}function st(t,...n){const e=b("Enter",{state:r},t);if(e)throw new TypeError(e);return(...e)=>nt(t,...n,...e)}function ct(t){const n=K(),e=q(),r=`${void 0===n?"[undefined]":n}->${e}`,o=Q();o.length?O.info(`${f}: ${t}\n  > Previous transition: "${r}"\n  > From "${e}", valid states are: [${o.map((t=>`"${t}"`)).join(", ")}]`):O.info(`${f}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${e}"`)}function at(t){const{description:n,table:e}=t.toValue();O.log(n),e.length?O.table(e):O.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const n=t.flat(),e=b("canTransitionTo",{state:r},n[0]);if(e)throw new TypeError(e);if(!n.length)return!1;const o=Q();return n.every((t=>o.includes(t)))},currentState:q,emit:tt,Emit:it,enter:nt,Enter:st,history:()=>[...j],info:()=>(O.log(`${f}: Information about this state-machine`),at(V),at(W),void at(z)),inspect:()=>({states:V.refs(),transitions:W.refs(),events:z.refs()}),inState:Z,InState:function(...t){const n=b("InState",{state:[r,i]},t[0]);if(n)throw new TypeError(n);return i(t[0])?(function(t,...n){return(...e)=>Z(t,...n,...e)})(...t):(function(t,n,...e){return(...r)=>Z(t,n,...e,...r)})(...t)},name:()=>s,onEntered:ot[C],onEntering:ot[L],onEvent:et,onExited:ot[N],onExiting:ot[I],onSwitched:rt[M],onSwitching:rt[P],onTransitions:t=>J(t,"onTransitions"),pause:D,paused:Y,performTransitions:t=>J(t,"performTransitions"),previousState:K,reset:function(){O.warn(`${f}: State-machine reset!`),j.length=0,j.push(y)},resume:F,statesAvailableFromHere:Q}},exports.assertRoute=function(t,n,e){const r=D("assertRoute",{machine:R,expectedRoute:s},t,n);if(r)throw TypeError(r);F+=1;const{description:o="Assertion complete",fromState:i="",run:c=(()=>{}),permittedDeviations:a=0,timeoutInMs:u=1e3,logLevel:h=3}=e||{},m=d(h),g=`Statebot[${t.name()}]: aId<${F}>`,$=b(n);m.log(`\n${g}: Asserting route: [${$.join(" > ")}]`),m.log(`${g}: > Assertion will start from state: "${i}"`);const w=f(c);let v=()=>{};const E=Y();let T,y=Y(),S=0,O=!0,A=!1;const j=[...$],x=(function(t,n){n=n||[];const e=[],r=(t=t||[]).map(((t,e)=>n[e]||"center"));let o=!1;function i(){o=!0}function s(...n){if(o)return;const r=t.reduce(((t,e,r)=>({...t,[e]:n[r]||""})),{});e.push(r)}function c(){return e.reduce(((n,e)=>t.map(((t,r)=>Math.max(e[t].length,n[r])))),t.map((()=>0)))}function a(){const n=c();function o(t,e){const o=n[e],i=r[e];return"left"===i?t.padEnd(o):"right"===i?t.padStart(o):t}return e.reduce(((n,e)=>[...n,t.reduce(((t,n,r)=>({...t,[n]:o(e[n],r)})),{})]),[])}return{lock:i,addRow:s,content:a}})(["state","expected","info","took"],["center","center","left","right"]),I=l((t=>(L("","","","TOTAL: "+E()),x.lock(),m.log(`\n${g}: ${o}: [${t?"FAILED":"SUCCESS"}]`),m.table(x.content()),t))),{addRow:L}=x;return new Promise(((n,e)=>{if(0===j.length)return void e(I(new Error("NO ROUTE TO TEST")));const r=n=>{for(;j.length;){const e=j.shift();L(t.currentState(),`(${e})`,n),A=!1}(t=>{clearTimeout(T),v(),c(),e(t)})(I(new Error(n)))};t.inState(i)&&(O=!1,v=w());const{revoke:o,fn:s}=p((t=>{T=setTimeout((()=>{o(),r("TIMEOUT")}),u),(function(t){if(O)L(t,"-","PENDING");else{const n=j[0];n===t?(L(t,n,A?"REALIGNED":"OKAY",y()),A=!1,j.shift()):(L(t,n,"WRONG STATE",y()),A=!0,S+=1),y=Y()}})(t),O&&t===i&&(O=!1,v=w()),S>a&&(o(),r("TOO MANY DEVIATIONS")),j.length<=0&&(o(),((...t)=>{clearTimeout(T),v(),c(),n(...t)})(I()))})),c=t.onSwitching(s)}))},exports.decomposeChart=S,exports.isStatebot=R,exports.routeIsPossible=function(t,n){const e=D("routeIsPossible",{machine:R,route:s},t,n);if(e)throw TypeError(e);const r=b(n);return r.every(((n,e)=>{if(e===r.length-1)return!0;{const o=r[e+1];return t.statesAvailableFromHere(n).includes(o)}}))};
