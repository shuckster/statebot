/*
 * Statebot
 * v2.5.1
 * https://shuckster.github.io/statebot/
 * License: MIT
 */
"use strict";function t(t){return{all:t=t||new Map,on:function(n,e){var r=t.get(n);r&&r.push(e)||t.set(n,[e])},off:function(n,e){var r=t.get(n);r&&r.splice(r.indexOf(e)>>>0,1)},emit:function(n,e){(t.get(n)||[]).slice().map((function(t){t(e)})),(t.get("*")||[]).slice().map((function(t){t(n,e)}))}}}function n(t){return Array.isArray(t)}function e(t){return"function"==typeof t}function r(t){return"string"==typeof t}function o(t){return"object"==typeof t}function i(t){return!(null===t||!o(t))&&Object.getPrototypeOf(t)===Object.prototype}function s(t){return!!r(t)||!!n(t)&&t.every(r)}function c(t){return t.reduce(((t,n)=>-1===t.indexOf(n)?[...t,n]:t),[])}function a(t){return(...n)=>(function(t,...n){const e=setTimeout(t,0,...n);return()=>clearTimeout(e)})(t,...n)}function u(t){let n,e=!1;return{fn:(...r)=>(e||(n=t(...r)),n),revoke:()=>{e=!0}}}function f(t,n,e,...r){const o=[...r].flat().reduce(((t,n)=>({...t,[n]:0})),{});function i(t){const n=s(t)-1;o[t]=Math.max(n,0)}function s(t){return o[t]||0}return{increase:function(t){return o[t]=s(t)+1,()=>i(t)},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${e}:`,table:Object.keys(o).sort().map((t=>[t,o[t]])).map((([t,e])=>({[n]:t,refs:e||"None"})))}},refs:function(){return{...o}}}}Object.defineProperty(exports,"__esModule",{value:!0});function l(t=""){return function(n,r,...o){const i=Object.keys(r).join(", "),s=Object.entries(r).map((([t,n])=>({argName:t,argType:n}))),c=o.map(((...t)=>((t,n,r)=>{const{argName:o,argType:i}=t[r];if(void 0===n)return`Argument undefined: "${o}"`;const s=e(i)?((t,n,e)=>n(e)?void 0:`${n.name}(${t}) did not return true`)(o,i,n):((t,n,e)=>typeof e===n?void 0:`Argument "${t}" should be a ${n}`)(o,i,n);return s?`${s}: ${o} === ${typeof n}(${n})`:void 0})(s,...t))).filter(Boolean);if(c.length)return`\n${t}${n}(${i}):\n${c.map((t=>`> ${t}`)).join("\n")}`}}function p(t){let n=t;function e(){return n>=1}function o(){return n>=2}function i(){return n>=3}return r(n)&&(n={info:3,log:2,warn:1,none:0}[n]||3),{canWarn:e,canLog:o,canInfo:i,info:(...t)=>i()&&console.info(...t),table:(...t)=>o()&&console.table(...t),log:(...t)=>o()&&console.log(...t),warn:(...t)=>e()&&console.warn(...t),error:(...t)=>console.error(...t)}}const m=/[\r\n]/,h="|",d="->",$=[h,d].map((t=>t.replace("|","\\|"))).join("|"),g=new RegExp(`(${$})$`),w=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,E=/(\/\/[^\n\r]*)/,v=l("statebot.");function T(t){const n=v("decomposeRoute",{templateLiteral:s},t);if(n)throw TypeError(n);return S(y(t)).flat(2)}function b(t){const n=v("decomposeChart",{chart:s},t);if(n)throw TypeError(n);const e=S(y(t)),r=e.map(O).flat(1).map(x).flat(1);let o=!1;const i=c(r.map((t=>(t.includes("")&&(o=!0),t.join(d))))),a=c(e.flat(3));return{transitions:i.map((t=>t.split(d))),routes:i,states:o?a:a.filter(Boolean)}}function y(t){const n=(function(t){return[t].flat().reduce(((t,n)=>[...t,n.split(m)]),[]).flat()})(t),e=[];let r=!1;const o=n.reduce(((t,n)=>{const o=n.replace(E,"").replace(w,"");return o?(r=g.test(o),r?t+o:(e.push(t+o),"")):t}),"");return r||o?[...e,o]:[...e]}function S(t){return t.map((t=>t.split(d).map((t=>t.split(h)))))}function O(t){const n=[];return t.reduce(((t,e)=>(!1===t||n.push([t,[...e]]),[...e])),!1),n}function x([t,n]){return t.reduce(((t,e)=>[...t,...n.map((t=>[e,t]))]),[])}const A="onExiting",I="onEntering",j="onExited",L="onEntered",N="onSwitching",P="onSwitched",_={[N]:"(ANY)state:changing",[P]:"(ANY)state:changed"};function k(t,n){const e=[],r=[];return{configs:t.reduce(((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=b(i);return n()&&(e.push(...c),r.push(...a)),[...t,...u.map((([t,n])=>({fromState:t,toState:n,action:s})))]}),[]),states:e,routes:r}}function R(t){return i(t)&&"number"==typeof t.__STATEBOT__}const C=l("statebot.");let D=0;function F(){const t=Date.now();function n(t,n){return t.toFixed(n).replace(/\.0+$/,"")}return function(){const e=Date.now()-t;return e<500?`${n(e)} ms`:e<5e3?`${n(e/1e3,2)} s `:e<6e4?`${n(e/1e3,1)} s `:`${n(e/1e3/60,1)} m `}}exports.Statebot=function(s,c){if(!r(s))throw new TypeError("\nStatebot: Please specify a name for this machine");const a=`Statebot[${s}]`;if(!i(c))throw new TypeError(`\n${a}: Please specify options for this machine`);const{chart:u,logLevel:m=3,historyLimit:h=2}=c||{},$=void 0===c.events?t():o(g=c.events)&&e(g.emit)&&(e(g.addListener)||e(g.on))&&(e(g.removeListener)||e(g.off))&&(function(t){const n=t.emit,e=t.addListener?t.addListener:t.on,r=t.removeListener?t.removeListener:t.off;return{emit:n,on:e,off:r}})(c.events);var g;if(!$)throw new TypeError(`\n${a}: Invalid event-emitter specified in options`);const{states:w=[],routes:E=[]}=u?b(u):c,{startIn:v=w[0]}=c;if(!w.includes(v))throw new Error(`${a}: Starting-state not in chart: "${v}"`);const T=l(`${a}#`),y=p(m),{canWarn:S}=y,O=[v],x=Math.max(h,2),R=t();let C=0;const{pause:D,resume:F,paused:M,Pausable:B}=(function(t=!1,n=(()=>{})){let e=!!t;return{Pausable:function(t){return(...r)=>e?(n(),!1):t(...r)},paused:()=>e,pause:()=>{e=!0},resume:()=>{e=!1}}})(!1,(()=>y.warn(`${a}: Ignoring callback, paused`))),Y=B(((t,...n)=>R.emit(t,n)));function G(t,n){const e=t=>n(...t);return R.on(t,e),()=>R.off(t,e)}const H=f(s,"states","Listening for the following state-changes",[...w]),U=f(s,"transitions","Listening for the following transitions",[...E]),V=f(s,"events","Listening for the following events");function W(t,o){const c=e(t)?t({enter:X,emit:Q,Enter:rt,Emit:et}):i(t)?t:null;if(!i(c))throw new TypeError(`Statebot[${s}]#${o}(): Expected an object, or a function that returns an object`);const{transitionsForEvents:a,transitionsOnly:u}=(function(t){const o={},s=[];return Object.entries(t).map((([t,c])=>{if(e(c))return void s.push({routeChart:t,action:c});if(!i(c))return;const{on:a,then:u}=c;if(r(a)||n(a)){[a].flat().map((n=>{o[n]=o[n]||[],o[n].push({routeChart:t,action:u})}))}else e(u)&&s.push({routeChart:t,action:c})})),{transitionsForEvents:o,transitionsOnly:s}})(c),f=[],l=[],p=[],m=Object.entries(a).reduce(((t,[n,e])=>{const{states:r,routes:o,configs:i}=k(e,S);return S()&&(f.push(...r),l.push(...o)),{...t,[n]:i}}),{});function h({fromState:t,toState:n,action:r,args:o}){return J(t,(()=>(X(n,...o),e(r)&&r(...o),!0)))}p.push(...Object.entries(m).map((function([t,n]){return[V.increase(t),Z(t,((...e)=>{n.map((t=>({...t,args:e}))).some(h)||ot(`Event not handled: "${t}"`)}))]})).flat());const d=k(u,S);if(S()&&(f.push(...d.states),l.push(...d.routes)),p.push(...d.configs.map((function(t){const{fromState:n,toState:e,action:r}=t,o=`${n}->${e}`;return[U.increase(o),G(o,r)]})).flat()),S()){const t=f.filter((t=>!w.includes(t))),n=l.filter((t=>!E.includes(t)));t.length&&y.warn(`Statebot[${s}]#${o}(): Invalid states specified:\n`+t.map((t=>`  > "${t}"`)).join("\n")),n.length&&y.warn(`Statebot[${s}]#${o}(): Invalid transitions specified:\n`+n.map((t=>`  > "${t}"`)).join("\n"))}return()=>p.map((t=>t()))}function z(){return O[O.length-2]}function K(){return O[O.length-1]}function q(t){const n=void 0!==t?t:K(),e=T("statesAvailableFromHere",{state:r},n);if(e)throw new TypeError(e);return E.reduce(((t,e)=>{const[r,o]=e.split(d).map((t=>t.trim()));return r===n?[...t,o]:t}),[])}function J(t,n,...o){const i=T("inState",{state:r},t);if(i)throw new TypeError(i);const s=K()===t;return void 0===n?s:s?e(n)?n(...o):n:null}const Q=B(((t,...n)=>{const e=T("emit",{eventName:r},t);if(e)throw new TypeError(e);return $.emit(t,...n)})),X=B(((t,...n)=>{const e=T("enter",{state:r},t);if(e)throw new TypeError(e);const o=K(),i=t;if(i===o)return ot(`Already in state: "${i}"`),!1;if(!w.includes(i))return ot(`Invalid state "${i}", not switching`),!1;const s=`${o}->${i}`;return E.includes(s)?(y.info(`${a}: tId<${++C}>: ${s}`),O.push(i),O.length>x&&O.shift(),Y(_[N],i,o,...n),Y(s,...n),Y(_[P],i,o,...n),!0):(ot(`Invalid transition "${s}", not switching`),!1)}));function Z(t,n){const o=T("onEvent",{eventName:r,cb:e},t,n);if(o)throw new TypeError(o);return $.on(t,n),()=>$.off(t,n)}const tt=Object.keys(_).reduce(((t,n)=>({...t,[n]:t=>{const r=T(n,{cb:e},t);if(r)throw new TypeError(r);const o=H.increase(_[n]),i=G(_[n],t);return()=>{i(),o()}}})),{}),nt=[[A,N],[I,N],[j,P],[L,P]].reduce(((t,n)=>{const[o,i]=n,s=o.slice(2),c=s.toLowerCase();return{...t,[o]:(t,n)=>{const a=T(o,{state:r,cb:e},t,n);if(a)throw new TypeError(a);const u=[H.increase(t),H.increase(`${t}:${c}`)],f=tt[i](((e,r,...o)=>{0===s.indexOf("Exit")?t===r&&n(e,...o):t===e&&n(r,...o)}));return()=>{f(),u.map((t=>t()))}}}}),{});function et(t,...n){const e=T("Emit",{eventName:r},t);if(e)throw new TypeError(e);return(...e)=>Q(t,...n,...e)}function rt(t,...n){const e=T("Enter",{state:r},t);if(e)throw new TypeError(e);return(...e)=>X(t,...n,...e)}function ot(t){const n=z(),e=K(),r=`${void 0===n?"[undefined]":n}->${e}`,o=q();o.length?y.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > From "${e}", valid states are: [${o.map((t=>`"${t}"`)).join(", ")}]`):y.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${e}"`)}function it(t){const{description:n,table:e}=t.toValue();y.log(n),e.length?y.table(e):y.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const n=t.flat(),e=T("canTransitionTo",{state:r},n[0]);if(e)throw new TypeError(e);if(!n.length)return!1;const o=q();return n.every((t=>o.includes(t)))},currentState:K,emit:Q,Emit:et,enter:X,Enter:rt,history:()=>[...O],info:()=>(y.log(`${a}: Information about this state-machine`),it(H),it(U),void it(V)),inspect:()=>({states:H.refs(),transitions:U.refs(),events:V.refs()}),inState:J,InState:function(t,n,...e){const o=T("InState",{state:r},t);if(o)throw new TypeError(o);return(...r)=>J(t,n,...e.concat(r))},name:()=>s,onEntered:nt[L],onEntering:nt[I],onEvent:Z,onExited:nt[j],onExiting:nt[A],onSwitched:tt[P],onSwitching:tt[N],onTransitions:t=>W(t,"onTransitions"),pause:D,paused:M,performTransitions:t=>W(t,"performTransitions"),previousState:z,reset:function(){y.warn(`${a}: State-machine reset!`),O.length=0,O.push(v)},resume:F,statesAvailableFromHere:q}},exports.assertRoute=function(t,n,e){const r=C("assertRoute",{machine:R,expectedRoute:s},t,n);if(r)throw TypeError(r);D+=1;const{description:o="Assertion complete",fromState:i="",run:c=(()=>{}),permittedDeviations:f=0,timeoutInMs:l=1e3,logLevel:m=3}=e||{},h=p(m),d=`Statebot[${t.name()}]: aId<${D}>`,$=T(n);h.log(`\n${d}: Asserting route: [${$.join(" > ")}]`),h.log(`${d}: > Assertion will start from state: "${i}"`);const g=a(c);let w=()=>{};const E=F();let v,b=F(),y=0,S=!0,O=!1;const x=[...$],A=(function(t=[],n=[]){const e=[],r=t.map(((t,e)=>n[e]||"center"));let o=!1;function i(){o=!0}function s(...n){if(o)return;const r=t.reduce(((t,e,r)=>({...t,[e]:n[r]||""})),{});e.push(r)}function c(){return e.reduce(((n,e)=>t.map(((t,r)=>Math.max(e[t].length,n[r])))),t.map((()=>0)))}function a(t,n){return t+" ".repeat(n-t.length)}function u(t,n){return" ".repeat(n-t.length)+t}function f(){const n=c();function o(t,e){const o=n[e],i=r[e];return"left"===i?a(t,o):"right"===i?u(t,o):t}return e.reduce(((n,e)=>[...n,t.reduce(((t,n,r)=>({...t,[n]:o(e[n],r)})),{})]),[])}return{lock:i,addRow:s,content:f}})(["state","expected","info","took"],["center","center","left","right"]),I=(function(t){const{revoke:n,fn:e}=u(t);let r;return function(...t){return r=e(...t),n(),r}})((t=>(j("","","","TOTAL: "+E()),A.lock(),h.log(`\n${d}: ${o}: [${t?"FAILED":"SUCCESS"}]`),h.table(A.content()),t))),{addRow:j}=A;return new Promise(((n,e)=>{if(0===x.length)return void e(I(new Error("NO ROUTE TO TEST")));const r=n=>{for(;x.length;){const e=x.shift();j(t.currentState(),`(${e})`,n),O=!1}(t=>{clearTimeout(v),w(),c(),e(t)})(I(new Error(n)))};t.inState(i)&&(S=!1,w=g());const{revoke:o,fn:s}=u((t=>{v=setTimeout((()=>{o(),r("TIMEOUT")}),l),(function(t){if(S)j(t,"-","PENDING");else{const n=x[0];n===t?(j(t,n,O?"REALIGNED":"OKAY",b()),O=!1,x.shift()):(j(t,n,"WRONG STATE",b()),O=!0,y+=1),b=F()}})(t),S&&t===i&&(S=!1,w=g()),y>f&&(o(),r("TOO MANY DEVIATIONS")),x.length<=0&&(o(),((...t)=>{clearTimeout(v),w(),c(),n(...t)})(I()))})),c=t.onSwitching(s)}))},exports.decomposeChart=b,exports.isStatebot=R,exports.routeIsPossible=function(t,n){const e=C("routeIsPossible",{machine:R,route:s},t,n);if(e)throw TypeError(e);const r=T(n);return r.every(((n,e)=>{if(e===r.length-1)return!0;{const o=r[e+1];return t.statesAvailableFromHere(n).includes(o)}}))};
