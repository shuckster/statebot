/*
 * Statebot
 * v2.5.0
 * https://shuckster.github.io/statebot/
 * License: ISC
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=(t=require("events"))&&"object"==typeof t&&"default"in t?t.default:t;function n(t){return Array.isArray(t)}function r(t){return"function"==typeof t}function o(t){return"string"==typeof t}function i(t){return"object"==typeof t}function s(t){return!(null===t||!i(t))&&Object.getPrototypeOf(t)===Object.prototype}function c(t){return!!o(t)||!!n(t)&&t.every(t=>o(t))}function a(t){return t.reduce((t,e)=>-1===t.indexOf(e)?[...t,e]:t,[])}function u(t){return(...e)=>(function(t,...e){const n=setTimeout(t,0,...e);return()=>{clearTimeout(n)}})(t,...e)}function f(t){let e,n=!1;return{fn:(...r)=>(n||(e=t(...r)),e),revoke:()=>{n=!0}}}function l(t,e,n,...r){const o={};function i(t){const e=s(t)-1;o[t]=Math.max(e,0)}function s(t){return o[t]||0}return[...r].flat().forEach(t=>{o[t]=0}),{increase:function(t){return o[t]=s(t)+1,()=>i(t)},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${n}:`,table:Object.keys(o).sort().map(t=>[t,o[t]]).map(([t,n])=>({[e]:t,refs:n||"None"}))}},refs:function(){return{...o}}}}function p(t=""){return function(e,n,...o){const i=Object.entries(n).map(([t,e])=>({argName:t,argType:e})),s=Object.keys(n).join(", "),c=o.map((t,e)=>{const{argName:n,argType:o}=i[e];if(void 0===t)return`Argument undefined: "${n}"`;let s,c,a;return r(o)?(a=!0===o(t),c=o.name,s=`${c}(${n}) did not return true`):(a=typeof t===o,c=o,s=`Argument "${n}" should be a ${c}`),a?void 0:`${s}: ${n} === ${typeof t}(${t})`}).filter(Boolean);return c.length?`\n${t}${e}(${s}):\n`+c.map(t=>"> "+t).join("\n"):void 0}}function h(t){let e=t;function n(){return e>=1}function r(){return e>=2}function i(){return e>=3}return o(e)&&(e={info:3,log:2,warn:1,none:0}[e]||3),{canWarn:n,canLog:r,canInfo:i,info:(...t)=>i()&&console.info(...t),table:(...t)=>r()&&console.table(...t),log:(...t)=>r()&&console.log(...t),warn:(...t)=>n()&&console.warn(...t),error:(...t)=>console.error(...t)}}const d=/[\r\n]/,m="|",g="->",$=[m,g].map(t=>t.replace("|","\\|")).join("|"),E=new RegExp(`(${$})$`),w=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,v=/(\/\/[^\n\r]*)/,T=p("statebot.");function S(t){const e=T("decomposeRoute",{templateLiteral:c},t);if(e)throw TypeError(e);return O(y(t)).flat(2)}function b(t){const e=T("decomposeChart",{chart:c},t);if(e)throw TypeError(e);const n=O(y(t)),r=n.map(x).flat(1).map(L).flat(1);let o=!1;const i=a(r.map(t=>(t.includes("")&&(o=!0),t.join(g)))),s=a(n.flat(3));return{transitions:i.map(t=>t.split(g)),routes:i,states:o?s:s.filter(Boolean)}}function y(t){const e=(function(t){return[t].flat().reduce((t,e)=>[...t,e.split(d)],[]).flat()})(t),n=[];let r=!1;const o=e.reduce((t,e)=>{const o=e.replace(v,"").replace(w,"");return o?(r=E.test(o),r?t+o:(n.push(t+o),"")):t},"");return r||o?[...n,o]:[...n]}function O(t){return t.map(t=>t.split(g).map(t=>t.split(m)))}function x(t){const e=[];return t.reduce((t,n)=>(!1===t||e.push([t,[...n]]),[...n]),!1),e}function L([t,e]){return t.reduce((t,n)=>[...t,...e.map(t=>[n,t])],[])}function j(t,e){const n=[],r=[];return{configs:t.reduce((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=b(i);return e()&&(n.push(...c),r.push(...a)),[...t,...u.map(t=>{const[e,n]=t;return{fromState:e,toState:n,action:s}})]},[]),states:n,routes:r}}function A(t){return s(t)&&"number"==typeof t.__STATEBOT__}const I=p("statebot.");let N=0;function P(){const t=Date.now();function e(t,e){return t.toFixed(e).replace(/\.0+$/,"")}return function(){const n=Date.now()-t;return n<500?e(n)+" ms":n<5e3?e(n/1e3,2)+" s ":n<6e4?e(n/1e3,1)+" s ":e(n/1e3/60,1)+" m "}}exports.Statebot=function(t,c){if(!o(t))throw TypeError("\nStatebot: Please specify a name for this machine");const a=`Statebot[${t}]`;if(!s(c))throw TypeError(`\n${a}: Please specify options for this machine`);const{chart:u,logLevel:f=3,historyLimit:d=2}=c||{},m=void 0===c.events?new e:i($=c.events)&&r($.emit)&&(r($.addListener)||r($.on))&&(r($.removeListener)||r($.off))&&(function(t){const e=(...e)=>t.emit(...e),n=t.addListener?(...e)=>t.addListener(...e):(...e)=>t.on(...e),r=t.removeListener?(...e)=>t.removeListener(...e):(...e)=>t.off(...e);return{emit:e,addListener:n,removeListener:r}})(c.events);var $;if(!m)throw TypeError(`\n${a}: Invalid event-emitter specified in options`);const{states:E=[],routes:w=[]}=u?b(u):c,{startIn:v=E[0]}=c;if(!E.includes(v))throw Error(`${a}: Starting-state not in chart: "${v}"`);const T=p(a+"#"),S=h(f),{canWarn:y}=S,O=[v],x=Math.max(d,2),L=new e,A={onSwitching:"(ANY)state:changing",onSwitched:"(ANY)state:changed"};let I=0;const{pause:N,resume:P,paused:_,Pausable:k}=(function(t=!1,e=(()=>{})){let n=!!t;return{Pausable:function(t){return(...r)=>n?(e(),!1):t(...r)},paused:()=>n,pause:()=>{n=!0},resume:()=>{n=!1}}})(!1,()=>S.warn(a+": Ignoring callback, paused")),R=k((t,...e)=>L.emit(t,...e));function C(t,e){return L.addListener(t,e),()=>L.removeListener(t,e)}const D=l(t,"states","Listening for the following state-changes",[...E]),M=l(t,"transitions","Listening for the following transitions",[...w]),F=l(t,"events","Listening for the following events");function B(e,i){const c=r(e)?e({enter:W,emit:V,Enter:Q,Emit:J}):s(e)?e:null;if(!s(c))throw TypeError(`Statebot[${t}]#${i}(): Expected an object, or a function that returns an object`);const a={},u=[];Object.entries(c).forEach(([t,e])=>{if(r(e))u.push({routeChart:t,action:e});else if(!s(e))return;const{on:i,then:c}=e;if(o(i)||n(i)){[i].flat().forEach(e=>{a[e]=a[e]||[],a[e].push({routeChart:t,action:c})})}else r(c)&&u.push({routeChart:t,action:e})});const f=[],l=[],p=[],h=Object.entries(a).reduce((t,[e,n])=>{const{states:r,routes:o,configs:i}=j(n,y);return y()&&(f.push(...r),l.push(...o)),{...t,[e]:i}},{}),d=({fromState:t,toState:e,action:n,args:o})=>U(t,()=>(W(e,...o),r(n)&&n(...o),!0));p.push(...Object.entries(h).map(([t,e])=>[F.increase(t),q(t,(...n)=>{e.map(t=>({...t,args:n})).some(d)||X(`Event not handled: "${t}"`)})]).flat());const m=j(u,y);if(y()&&(f.push(...m.states),l.push(...m.routes)),p.push(...m.configs.map(t=>{const{fromState:e,toState:n,action:r}=t,o=`${e}->${n}`;return[M.increase(o),C(o,r)]}).flat()),y()){const e=f.filter(t=>!E.includes(t)),n=l.filter(t=>!w.includes(t));e.length&&S.warn(`Statebot[${t}]#${i}(): Invalid states specified:\n`+e.map(t=>`  > "${t}"`).join("\n")),n.length&&S.warn(`Statebot[${t}]#${i}(): Invalid transitions specified:\n`+n.map(t=>`  > "${t}"`).join("\n"))}return()=>p.forEach(t=>t())}function Y(){return O[O.length-2]}function G(){return O[O.length-1]}function H(t){const e=void 0!==t?t:G(),n=T("statesAvailableFromHere",{state:o},e);if(n)throw TypeError(n);return w.reduce((t,n)=>{const[r,o]=n.split(g).map(t=>t.trim());return r===e?[...t,o]:t},[])}function U(t,e,...n){const i=T("inState",{state:o},t);if(i)throw TypeError(i);const s=G()===t;return void 0===e?s:s?r(e)?e(...n):e:null}const V=k((t,...e)=>{const n=T("emit",{eventName:o},t);if(n)throw TypeError(n);return m.emit(t,...e)}),W=k((t,...e)=>{const n=T("enter",{state:o},t);if(n)throw TypeError(n);const r=G(),i=t;if(i===r)return X(`Already in state: "${i}"`),!1;if(!E.includes(i))return X(`Invalid state "${i}", not switching`),!1;const s=`${r}->${i}`;return w.includes(s)?(S.info(`${a}: tId<${++I}>: ${s}`),O.push(i),O.length>x&&O.shift(),R(A.onSwitching,i,r,...e),R(s,...e),R(A.onSwitched,i,r,...e),!0):(X(`Invalid transition "${s}", not switching`),!1)});function q(t,e){const n=T("onEvent",{eventName:o,cb:r},t,e);if(n)throw TypeError(n);return m.addListener(t,e),()=>m.removeListener(t,e)}const z=Object.keys(A).reduce((t,e)=>({...t,[e]:t=>{const n=T(e,{cb:r},t);if(n)throw TypeError(n);const o=D.increase(A[e]),i=C(A[e],t);return()=>{i(),o()}}}),{}),K=[["Exiting","onSwitching"],["Entering","onSwitching"],["Exited","onSwitched"],["Entered","onSwitched"]].reduce((t,e)=>{const[n,i]=e,s="on"+n,c=n.toLowerCase();return{...t,[s]:(t,e)=>{const a=T(s,{state:o,cb:r},t,e);if(a)throw TypeError(a);const u=[D.increase(t),D.increase(`${t}:${c}`)],f=z[i]((r,o,...i)=>{0===n.indexOf("Exit")?t===o&&e(r,...i):t===r&&e(o,...i)});return()=>{f(),u.map(t=>t())}}}},{});function J(t,...e){const n=T("Emit",{eventName:o},t);if(n)throw TypeError(n);return(...n)=>V(t,...e,...n)}function Q(t,...e){const n=T("Enter",{state:o},t);if(n)throw TypeError(n);return(...n)=>W(t,...e,...n)}function X(t){const e=Y(),n=G(),r=`${void 0===e?"[undefined]":e}->${n}`,o=H();o.length?S.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > From "${n}", valid states are: [${o.map(t=>`"${t}"`).join(", ")}]`):S.info(`${a}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${n}"`)}function Z(t){const{description:e,table:n}=t.toValue();S.log(e),n.length?S.table(n):S.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const e=t.flat(),n=T("canTransitionTo",{state:o},e[0]);if(n)throw TypeError(n);if(!e.length)return!1;const r=H();return e.every(t=>r.includes(t))},currentState:G,emit:V,Emit:J,enter:W,Enter:Q,history:()=>[...O],info:()=>(S.log(a+": Information about this state-machine"),Z(D),Z(M),void Z(F)),inspect:()=>({states:D.refs(),transitions:M.refs(),events:F.refs()}),inState:U,InState:function(t,e,...n){const r=T("InState",{state:o},t);if(r)throw TypeError(r);return(...r)=>U(t,e,...n,...r)},name:()=>t,onEntered:K.onEntered,onEntering:K.onEntering,onEvent:q,onExited:K.onExited,onExiting:K.onExiting,onSwitched:z.onSwitched,onSwitching:z.onSwitching,onTransitions:t=>B(t,"onTransitions"),pause:N,paused:_,performTransitions:t=>B(t,"performTransitions"),previousState:Y,reset:function(){S.warn(a+": State-machine reset!"),O.length=0,O.push(v)},resume:P,statesAvailableFromHere:H}},exports.assertRoute=function(t,e,n){const r=I("assertRoute",{machine:A,expectedRoute:c},t,e);if(r)throw TypeError(r);N+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:a=0,timeoutInMs:l=1e3,logLevel:p=3}=n||{},d=h(p),m=`Statebot[${t.name()}]: aId<${N}>`,g=S(e);d.log(`\n${m}: Asserting route: [${g.join(" > ")}]`),d.log(`${m}: > Assertion will start from state: "${i}"`);const $=u(s);let E=()=>{};const w=P();let v,T=P(),b=0,y=!0,O=!1;const x=[...g],L=(function(t=[],e=[]){const n=[],r=t.map((t,n)=>e[n]||"center");let o=!1;function i(){o=!0}function s(...e){if(o)return;const r=t.reduce((t,n,r)=>({...t,[n]:e[r]||""}),{});n.push(r)}function c(){return n.reduce((e,n)=>t.map((t,r)=>Math.max(n[t].length,e[r])),t.map(()=>0))}function a(t,e){return t+" ".repeat(e-t.length)}function u(t,e){return" ".repeat(e-t.length)+t}function f(){const e=c();function o(t,n){const o=e[n],i=r[n];return"left"===i?a(t,o):"right"===i?u(t,o):t}return n.reduce((e,n)=>[...e,t.reduce((t,e,r)=>({...t,[e]:o(n[e],r)}),{})],[])}return{lock:i,addRow:s,content:f}})(["state","expected","info","took"],["center","center","left","right"]),j=(function(t){const{revoke:e,fn:n}=f(t);let r;return function(...t){return r=n(...t),e(),r}})(t=>(_("","","","TOTAL: "+w()),L.lock(),d.log(`\n${m}: ${o}: [${t?"FAILED":"SUCCESS"}]`),d.table(L.content()),t)),{addRow:_}=L;return new Promise((e,n)=>{if(0===x.length)return void n(j(new Error("NO ROUTE TO TEST")));const r=e=>{for(;x.length;){const n=x.shift();_(t.currentState(),`(${n})`,e),O=!1}(t=>{clearTimeout(v),E(),c(),n(t)})(j(new Error(e)))};t.inState(i)&&(y=!1,E=$());const{revoke:o,fn:s}=f(t=>{v=setTimeout(()=>{o(),r("TIMEOUT")},l),(function(t){if(y)_(t,"-","PENDING");else{const e=x[0];e===t?(_(t,e,O?"REALIGNED":"OKAY",T()),O=!1,x.shift()):(_(t,e,"WRONG STATE",T()),O=!0,b+=1),T=P()}})(t),y&&t===i&&(y=!1,E=$()),b>a&&(o(),r("TOO MANY DEVIATIONS")),x.length<=0&&(o(),((...t)=>{clearTimeout(v),E(),c(),e(...t)})(j()))}),c=t.onSwitching(s)})},exports.decomposeChart=b,exports.isStatebot=A,exports.routeIsPossible=function(t,e){const n=I("routeIsPossible",{machine:A,route:c},t,e);if(n)throw TypeError(n);const r=S(e);return r.every((e,n)=>{if(n===r.length-1)return!0;{const o=r[n+1];return t.statesAvailableFromHere(e).includes(o)}})};
