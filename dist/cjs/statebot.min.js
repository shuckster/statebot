/*
 * Statebot
 * v2.9.2
 * https://shuckster.github.io/statebot/
 * License: MIT
 */
"use strict";function t(t){return{all:t=t||new Map,on:function(n,e){var r=t.get(n);r?r.push(e):t.set(n,[e])},off:function(n,e){var r=t.get(n);r&&(e?r.splice(r.indexOf(e)>>>0,1):t.set(n,[]))},emit:function(n,e){var r=t.get(n);r&&r.slice().map((function(t){t(e)})),(r=t.get("*"))&&r.slice().map((function(t){t(n,e)}))}}}function n(t){return f(t)&&o(t.emit)&&(o(t.addListener)||o(t.on))&&(o(t.removeListener)||o(t.off))}function e(t){return Array.isArray(t)}function r(t){return"[object Arguments]"===Object.prototype.toString.call(t)}function o(t){return"function"==typeof t}function i(t){return"string"==typeof t}function s(t){return e(t)&&t.every(i)}function a(t){return void 0===t}function c(t){return null===t}function u(t){return"number"==typeof t}function f(t){return"object"==typeof t&&!c(t)}function l(t){return!(c(t)||!f(t)||r(t))&&Object.getPrototypeOf(t)===Object.prototype}function p(t){return!!i(t)||!!e(t)&&t.every(i)}Object.defineProperty(exports,"__esModule",{value:!0}),n.displayName="isEventEmitter",e.displayName="isUnset",e.displayName="isArray",r.displayName="isArguments",o.displayName="isFunction",i.displayName="isString",s.displayName="isAllStrings",a.displayName="isUndefined",c.displayName="isNull",u.displayName="isNumber",f.displayName="isObject",l.displayName="isPojo",p.displayName="isTemplateLiteral";function m(t){return n=>{const e=Object.entries(n).map((([t,n])=>({argName:t,argType:n})));return s=>(...c)=>{const u=Array.from(c,(t=>r(t)?Array.from(t):t)).flat(1).map((t=>(n,e)=>{if(e>=t.length)return;const{argName:r,argType:s}=t[e];if(a(n))return`Argument undefined: "${r}"`;const c=Array.isArray(s)?s:[s],u=c.map((t=>o(t)?((t,n,e)=>n(e)?void 0:(n.displayName||n.name)+`(${t}) did not return true`)(r,t,n):((t,n,e)=>typeof e===n?void 0:`Argument "${t}" should be a ${n}`)(r,t,n))).filter(i);return(c.length>1?u.length>1:u.length)?u.join("\n| ")+`\n> typeof ${r} === ${typeof n}(${JSON.stringify(n)})`:void 0})(e)).filter(i);if(!u.length)return;const f=Object.keys(n).join(", ");return`\n${t||""}${s}(${f}):\n${u.map((t=>`| ${t}`)).join("\n")}`}}}function d(t){const n=t.addListener?(...n)=>t.addListener(...n):(...n)=>t.on(...n),e=t.removeListener?(...n)=>t.removeListener(...n):(...n)=>t.off(...n),r=new Map;return{emit:(n,...e)=>t.emit(n,e),on:function(t,e){let o=r.get(e);o||(o={handleEvent:(t=[])=>e(...[t].flat()),refCount:0},r.set(e,o)),o.refCount+=1,n(t,o.handleEvent)},off:function(t,n){let o=r.get(n);o&&(e(t,o.handleEvent),o.refCount-=1,0===o.refCount&&r.delete(n))}}}function h(t){return t.reduce(((t,n)=>-1===t.indexOf(n)?(t.push(n),t):t),[])}function g(t){return(...n)=>(function(t,...n){const e=setTimeout(t,0,...n);return()=>{clearTimeout(e)}})(t,...n)}function $(t){const{revoke:n,fn:e}=w(t);let r;return function(...t){return r=e(...t),n(),r}}function w(t){let n,e=!1;return{fn:(...r)=>(e||(n=t(...r)),n),revoke:()=>{e=!0}}}function y(t,n,e,...r){const o=[...r].flat().reduce(((t,n)=>({...t,[n]:0})),{});function i(t){const n=s(t)-1;o[t]=Math.max(n,0)}function s(t){return o[t]||0}return{increase:function(t){return o[t]=s(t)+1,()=>{i(t)}},decrease:i,countOf:s,toValue:function(){return{description:`${t}: ${e}:`,table:Object.keys(o).sort().map((t=>[t,o[t]])).map((([t,e])=>({[n]:t,refs:e||"None"})))}},refs:function(){return{...o}}}}function E(t,n){function e(){return t>=1}function r(){return t>=2}function o(){return t>=3}i(t)&&(t={info:3,log:2,warn:1,none:0}[t]||3);const{info:s,table:a,log:c,warn:u,error:f}=n||console;return{canWarn:e,canLog:r,canInfo:o,info:(...t)=>{o()&&s(...t)},table:(...t)=>{r()&&a(...t)},log:(...t)=>{r()&&c(...t)},warn:(...t)=>{e()&&u(...t)},error:(...t)=>{f(...t)}}}const T=/[\r\n]/,v="|",b="->",S=[v,b].map((t=>t.replace("|","\\|"))).join("|"),O=new RegExp(`(${S})$`),N=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,j=/(\/\/[^\n\r]*)/,A=m("statebot.");function x(t){const n=A({templateLiteral:p})("decomposeRoute")(t);if(n)throw TypeError(n);return k(L(t)).flat(2)}function I(t){const n=A({chart:p})("decomposeChart")(t);if(n)throw TypeError(n);const e=k(L(t)),r=e.flatMap(C).flatMap(P);let o=!1;const i=h(r.map((t=>(t.includes("")&&(o=!0),t.join(b))))),s=h(e.flat(3));return{transitions:i.map((t=>t.split(b))),routes:i,states:o?s:s.filter(Boolean)}}function L(t){const n=(function(t){return[t].flat().reduce(((t,n)=>[...t,...n.split(T)]),[])})(t),e=[];let r=!1;const o=n.reduce(((t,n)=>{const o=n.replace(j,"").replace(N,"");return o?(r=O.test(o),r?t+o:(e.push(t+o),"")):t}),"");return r||o?[...e,o]:[...e]}function k(t){return t.map((t=>t.split(b).map((t=>t.split(v)))))}function C(t){const n=[];return t.reduce(((t,e)=>(!1===t||n.push([t,[...e]]),[...e])),!1),n}function P([t,n]){return t.reduce(((t,e)=>(t.push(...n.map((t=>[e,t]))),t)),[])}const M="onExiting",R="onEntering",_="onExited",F="onEntered",D="onSwitching",U="onSwitched",W={[D]:"(ANY)state:changing",[U]:"(ANY)state:changed"};function Y(t,n){const e=[],r=[];return{configs:t.reduce(((t,o)=>{const{routeChart:i,action:s}=o,{states:a,routes:c,transitions:u}=I(i);return n()&&(e.push(...a),r.push(...c)),[...t,...u.map((([t,n])=>({fromState:t,toState:n,action:s})))]}),[]),states:e,routes:r}}function B(t){return l(t)&&u(t.__STATEBOT__)}const G=m("statebot.");let H=0;function V(){const t=Date.now();function n(t,n){return t.toFixed(n).replace(/\.0+$/,"")}return function(){const e=Date.now()-t;return e<500?`${n(e)} ms`:e<5e3?`${n(e/1e3,2)} s `:e<6e4?`${n(e/1e3,1)} s `:`${n(e/1e3/60,1)} m `}}exports.Statebot=function(r,c){if(!i(r))throw new TypeError("\nStatebot: Please specify a name for this machine");const u=`Statebot[${r}]`;if(!l(c))throw new TypeError(`\n${u}: Please specify options for this machine`);const{chart:f,logLevel:p=3,historyLimit:h=2}=c||{},g=a(c.events)?d(t()):n(c.events)&&d(c.events);if(!g)throw new TypeError(`\n${u}: Invalid event-emitter specified in options`);const{states:w=[],routes:T=[]}=f?I(f):c,{startIn:v=w[0]}=c;if(!w.includes(v))throw new Error(`${u}: Starting-state not in chart: "${v}"`);const S=m(`${u}#`),O=E(p,console),{canWarn:N}=O,j=[v],A=Math.max(h,2);let x=0;const{pause:L,resume:k,paused:C,Pausable:P}=(function(t,n){n=n||function(){};let e=!!t;return{Pausable:function(t){return(...r)=>e?(n(),!1):t(...r)},paused:()=>e,pause:()=>{e=!0},resume:()=>{e=!1}}})(!1,(()=>O.warn(`${u}: Ignoring callback, paused`))),B=(function(){const t={};function n(n,e){t[n]=(t[n]||[]).filter((t=>t!==e)),0===t[n].length&&delete t[n]}return{define:function(e,r){return t[e]=t[e]||[],t[e].push(r),()=>n(e,r)},undefine:n,definitionsOf:function(n){return t[n]||[]}}})(),G=d(t()),H=P(G.emit);function V(t,n){return G.on(t,n),()=>G.off(t,n)}const z=y(u,"states","Listening for the following state-changes",[...w]),J=y(u,"transitions","Listening for the following transitions",[...T]),K=y(u,"events","Listening for the following events");function q(t,n){const r=o(t)?t({enter:ot,emit:rt,Enter:ut,Emit:ct}):l(t)?t:null;if(!l(r))throw new TypeError(`${u}#${n}(): Expected an object, or a function that returns an object`);const s=[],a=[],{transitionsForEvents:c,transitionsOnly:f}=(function(t){const n={},r=[];return Object.entries(t).map((([t,s])=>{if(o(s))return void r.push({routeChart:t,action:s});if(!l(s))return;const{on:a,then:c}=s;if(i(a)||e(a)){[a].flat().map((e=>{n[e]=n[e]||[],n[e].push({routeChart:t,action:c})}))}else o(c)&&r.push({routeChart:t,action:s})})),{transitionsForEvents:n,transitionsOnly:r}})(r),p=Object.entries(c).reduce((function(t,[n,e]){const{states:r,routes:o,configs:i}=Y(e,N);N()&&(s.push(...r),a.push(...o));return{...t,[n]:i}}),{}),m=Y(f,N),d=Object.entries(p).map((function([t,n]){return[K.increase(t),it(t,((...e)=>{n.map((t=>({...t,args:e}))).some(h)||ft(`Event not handled: "${t}"`)}))].concat(n.map((({fromState:n,toState:e})=>B.define(`${t}:${n}`,e))))})).concat(m.configs.map((function(t){const{fromState:n,toState:e,action:r}=t,o=`${n}->${e}`;return[J.increase(o),V(o,(i=e,s=r,(...t)=>g(i,s,...t)))];var i,s}))).flat();if(N()){s.push(...m.states),a.push(...m.routes);const t=s.filter((t=>!w.includes(t))),e=a.filter((t=>!T.includes(t)));t.length&&O.warn(`${u}#${n}(): Invalid states specified:\n`+t.map((t=>`  > "${t}"`)).join("\n")),e.length&&O.warn(`${u}#${n}(): Invalid transitions specified:\n`+e.map((t=>`  > "${t}"`)).join("\n"))}return()=>d.map((t=>t()));function h({fromState:t,toState:n,action:e,args:r}){return et(t,(()=>(ot(n,...r),o(e)&&g(n,e,...r),!0)))}function g(t,n,...e){const r=n(...e);if(o(r)){const n=$(at[M](t,(t=>{n(),r(t)})));d.push(n)}}}function Q(t,n,e=!0){const r=S({eventName:i})("peek")(t);if(r)throw new TypeError(r);const s=t+":"+Z(),c=B.definitionsOf(s);if(c.length>1){const n=`${u}: Event "${t}" causes multiple transitions.\n  > From state: "${Z()}"\n  > To states: "${c.join(", ")}"\n\nCheck your performTransitions() config.`;throw new RangeError(n)}e||0!==c.length||(0===K.countOf(t)?O.warn(`${u}: Event not handled: "${t}"`):O.warn(`${u}: Will not transition after emitting: "${t}"`));const f=c[0];if(a(n))return a(f)?Z():f;const p=S({stateObject:l})("peek")(n);if(p)throw new TypeError(p);if(Object.prototype.hasOwnProperty.call(n,f)){const t=n[f];return o(t)?t():t}return null}function X(){return j[j.length-2]}function Z(){return j[j.length-1]}function tt(t){const n=a(t)?Z():t,e=S({state:i})("statesAvailableFromHere")(n);if(e)throw new TypeError(e);return T.reduce(((t,e)=>{const[r,o]=e.split(b).map((t=>t.trim()));return r===n?[...t,o]:t}),[])}function nt(t,n,...e){const r=Z()===t;return a(n)?r:r?o(n)?n(...e):n:null}function et(...t){const n=S({state:[i,l]})("inState")(t[0]);if(n)throw new TypeError(n);return l(t[0])?(function(t,...n){const e=Object.entries(t).find((([t])=>nt(t)));return e?nt(...e.concat(n)):null})(...t):nt(...t)}const rt=P(((t,...n)=>{const e=S({eventName:i})("emit")(t);if(e)throw new TypeError(e);return Q(t),g.emit(t,...n)})),ot=P(((t,...n)=>{const e=S({state:i})("enter")(t);if(e)throw new TypeError(e);const r=Z(),o=t;if(o===r)return ft(`Already in state: "${o}"`),!1;if(!w.includes(o))return ft(`Invalid state "${o}", not switching`),!1;const s=`${r}->${o}`;return T.includes(s)?(O.info(`${u}: tId<${++x}>: ${s}`),j.push(o),j.length>A&&j.shift(),H(W[D],o,r,...n),H(s,...n),H(W[U],o,r,...n),!0):(ft(`Invalid transition "${s}", not switching`),!1)}));function it(t,n){const e=S({eventName:i,cb:o})("onEvent")(t,n);if(e)throw new TypeError(e);return g.on(t,n),()=>g.off(t,n)}const st=Object.keys(W).reduce(((t,n)=>({...t,[n]:t=>{const e=S({cb:o})(n)(t);if(e)throw new TypeError(e);const r=z.increase(W[n]),i=V(W[n],t);return()=>{i(),r()}}})),{}),at=[[M,D],[R,D],[_,U],[F,U]].reduce(((t,n)=>{const[e,r]=n,s=e.slice(2),a=s.toLowerCase();return{...t,[e]:(t,n)=>{const c=S({state:i,cb:o})(e)(t,n);if(c)throw new TypeError(c);const u=[z.increase(t),z.increase(`${t}:${a}`)],f=st[r](((e,r,...o)=>{0===s.indexOf("Exit")?t===r&&n(e,...o):t===e&&n(r,...o)}));return()=>{f(),u.map((t=>t()))}}}}),{});function ct(t,...n){const e=S({eventName:i})("Emit")(t);if(e)throw new TypeError(e);return(...e)=>rt(t,...n,...e)}function ut(t,...n){const e=S({state:i})("Enter")(t);if(e)throw new TypeError(e);return(...e)=>ot(t,...n,...e)}function ft(t){const n=X(),e=Z(),r=`${a(n)?"[undefined]":n}->${e}`,o=tt();o.length?O.info(`${u}: ${t}\n  > Previous transition: "${r}"\n  > From "${e}", valid states are: [${o.map((t=>`"${t}"`)).join(", ")}]`):O.info(`${u}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${e}"`)}function lt(t){const{description:n,table:e}=t.toValue();O.log(n),e.length?O.table(e):O.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const n=t.flat();if(2===n.length&&i(n[0])&&l(n[1])){const t=n[0],{afterEmitting:e}=n[1],r=S({thisState:i,"{ afterEmitting }":i})("canTransitionTo")(t,e);if(r)throw new TypeError(r);return t!==Z()&&Q(e)===t}return(function(...t){const n=S({states:s})("canTransitionTo")([t]);if(n)throw new TypeError(n);if(!t.length)return!1;const e=tt();return t.every((t=>e.includes(t)))})(...n)},currentState:Z,emit:rt,Emit:ct,enter:ot,Enter:ut,history:()=>[...j],info:()=>(O.log(`${u}: Information about this state-machine`),lt(z),lt(J),void lt(K)),inspect:()=>({states:z.refs(),transitions:J.refs(),events:K.refs()}),inState:et,InState:function(...t){const n=S({state:[i,l]})("InState")(t[0]);if(n)throw new TypeError(n);return l(t[0])?(function(t,...n){return(...e)=>et(t,...n,...e)})(...t):(function(t,n,...e){return(...r)=>et(t,n,...e,...r)})(...t)},name:()=>r,onEntered:at[F],onEntering:at[R],onEvent:it,onExited:at[_],onExiting:at[M],onSwitched:st[U],onSwitching:st[D],onTransitions:t=>q(t,"onTransitions"),pause:L,paused:C,peek:function(t,n){return Q(t,n,!1)},performTransitions:t=>q(t,"performTransitions"),previousState:X,reset:function(){O.warn(`${u}: State-machine reset!`),j.length=0,j.push(v)},resume:k,statesAvailableFromHere:tt}},exports.assertRoute=function(t,n,e){const r=G({machine:B,expectedRoute:p})("assertRoute")(t,n);if(r)throw TypeError(r);H+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:a=0,timeoutInMs:c=1e3,logLevel:u=3}=e||{},f=E(u),l=`Statebot[${t.name()}]: aId<${H}>`,m=x(n);f.log(`\n${l}: Asserting route: [${m.join(" > ")}]`),f.log(`${l}: > Assertion will start from state: "${i}"`);const d=g(s);let h=()=>{};const y=V();let T,v=V(),b=0,S=!0,O=!1;const N=[...m],j=(function(t,n){n=n||[];const e=[],r=(t=t||[]).map(((t,e)=>n[e]||"center"));let o=!1;function i(){o=!0}function s(...n){if(o)return;const r=t.reduce(((t,e,r)=>({...t,[e]:n[r]||""})),{});e.push(r)}function a(){return e.reduce(((n,e)=>t.map(((t,r)=>Math.max(e[t].length,n[r])))),t.map((()=>0)))}function c(){const n=a();function o(t,e){const o=n[e],i=r[e];return"left"===i?t.padEnd(o):"right"===i?t.padStart(o):t}return e.reduce(((n,e)=>{const r=t.reduce(((t,n,r)=>({...t,[n]:o(e[n],r)})),{});return[...n,r]}),[])}return{lock:i,addRow:s,content:c}})(["state","expected","info","took"],["center","center","left","right"]),A=$((t=>(I("","","","TOTAL: "+y()),j.lock(),f.log(`\n${l}: ${o}: [${t?"FAILED":"SUCCESS"}]`),f.table(j.content()),t))),{addRow:I}=j;return new Promise(((n,e)=>{if(0===N.length)return void e(A(new Error("NO ROUTE TO TEST")));const r=n=>{for(;N.length;){const e=N.shift();I(t.currentState(),`(${e})`,n),O=!1}(t=>{clearTimeout(T),h(),u(),e(t)})(A(new Error(n)))};t.inState(i)&&(S=!1,h=d());const{revoke:o,fn:s}=w((t=>{T=setTimeout((()=>{o(),r("TIMEOUT")}),c),(function(t){if(S)I(t,"-","PENDING");else{const n=N[0];n===t?(I(t,n,O?"REALIGNED":"OKAY",v()),O=!1,N.shift()):(I(t,n,"WRONG STATE",v()),O=!0,b+=1),v=V()}})(t),S&&t===i&&(S=!1,h=d()),b>a&&(o(),r("TOO MANY DEVIATIONS")),N.length<=0&&(o(),((...t)=>{clearTimeout(T),h(),u(),n(...t)})(A()))})),u=t.onSwitching(s)}))},exports.decomposeChart=I,exports.isStatebot=B,exports.routeIsPossible=function(t,n){const e=G({machine:B,route:p})("routeIsPossible")(t,n);if(e)throw TypeError(e);const r=x(n);return r.every(((n,e)=>{if(e===r.length-1)return!0;{const o=r[e+1];return t.statesAvailableFromHere(n).includes(o)}}))};
