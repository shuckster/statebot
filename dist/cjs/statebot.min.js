/*
 * Statebot
 * v2.6.1
 * https://shuckster.github.io/statebot/
 * License: MIT
 */
"use strict";function t(t){return{all:t=t||new Map,on:function(n,e){var r=t.get(n);r&&r.push(e)||t.set(n,[e])},off:function(n,e){var r=t.get(n);r&&r.splice(r.indexOf(e)>>>0,1)},emit:function(n,e){(t.get(n)||[]).slice().map((function(t){t(e)})),(t.get("*")||[]).slice().map((function(t){t(n,e)}))}}}function n(t){return Array.isArray(t)}function e(t){return"function"==typeof t}function r(t){return"string"==typeof t}function o(t){return"object"==typeof t}function i(t){const n=t.addListener?(...n)=>t.addListener(...n):(...n)=>t.on(...n),e=t.removeListener?(...n)=>t.removeListener(...n):(...n)=>t.off(...n),r=new Map;return{emit:(n,...e)=>t.emit(n,e),on:function(t,e){let o=r.get(e);o||(o={handleEvent:t=>e(...t||[]),refCount:0},r.set(e,o)),o.refCount+=1,n(t,o.handleEvent)},off:function(t,n){let o=r.get(n);o&&(e(t,o.handleEvent),o.refCount-=1,0===o.refCount&&r.delete(n))}}}function s(t){return!(null===t||!o(t))&&Object.getPrototypeOf(t)===Object.prototype}function c(t){return!!r(t)||!!n(t)&&t.every(r)}function a(t){return t.reduce(((t,n)=>-1===t.indexOf(n)?[...t,n]:t),[])}function u(t){return(...n)=>(function(t,...n){const e=setTimeout(t,0,...n);return()=>clearTimeout(e)})(t,...n)}function f(t){let n,e=!1;return{fn:(...r)=>(e||(n=t(...r)),n),revoke:()=>{e=!0}}}function l(t,n,e,...r){const o=[...r].flat().reduce(((t,n)=>({...t,[n]:0})),{});function i(t){const n=s(t)-1;o[t]=Math.max(n,0)}function s(t){return o[t]||0}return{increase:function(t){return o[t]=s(t)+1,()=>i(t)},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${e}:`,table:Object.keys(o).sort().map((t=>[t,o[t]])).map((([t,e])=>({[n]:t,refs:e||"None"})))}},refs:function(){return{...o}}}}Object.defineProperty(exports,"__esModule",{value:!0});function p(t){return t=t||"",function(n,r,...o){const i=Object.keys(r).join(", "),s=Object.entries(r).map((([t,n])=>({argName:t,argType:n}))),c=o.map(((...t)=>((t,n,r)=>{const{argName:o,argType:i}=t[r];if(void 0===n)return`Argument undefined: "${o}"`;const s=e(i)?((t,n,e)=>n(e)?void 0:`${n.name}(${t}) did not return true`)(o,i,n):((t,n,e)=>typeof e===n?void 0:`Argument "${t}" should be a ${n}`)(o,i,n);return s?`${s}: ${o} === ${typeof n}(${n})`:void 0})(s,...t))).filter(Boolean);if(c.length)return`\n${t}${n}(${i}):\n${c.map((t=>`> ${t}`)).join("\n")}`}}function m(t,n){function e(){return t>=1}function o(){return t>=2}function i(){return t>=3}return n=n||console,r(t)&&(t={info:3,log:2,warn:1,none:0}[t]||3),{canWarn:e,canLog:o,canInfo:i,info:(...t)=>i()&&n.info(...t),table:(...t)=>o()&&n.table(...t),log:(...t)=>o()&&n.log(...t),warn:(...t)=>e()&&n.warn(...t),error:(...t)=>n.error(...t)}}const h=/[\r\n]/,d="|",$="->",g=[d,$].map((t=>t.replace("|","\\|"))).join("|"),w=new RegExp(`(${g})$`),E=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,v=/(\/\/[^\n\r]*)/,T=p("statebot.");function b(t){const n=T("decomposeRoute",{templateLiteral:c},t);if(n)throw TypeError(n);return O(S(t)).flat(2)}function y(t){const n=T("decomposeChart",{chart:c},t);if(n)throw TypeError(n);const e=O(S(t)),r=e.map(x).flat(1).map(A).flat(1);let o=!1;const i=a(r.map((t=>(t.includes("")&&(o=!0),t.join($))))),s=a(e.flat(3));return{transitions:i.map((t=>t.split($))),routes:i,states:o?s:s.filter(Boolean)}}function S(t){const n=(function(t){return[t].flat().reduce(((t,n)=>[...t,n.split(h)]),[]).flat()})(t),e=[];let r=!1;const o=n.reduce(((t,n)=>{const o=n.replace(v,"").replace(E,"");return o?(r=w.test(o),r?t+o:(e.push(t+o),"")):t}),"");return r||o?[...e,o]:[...e]}function O(t){return t.map((t=>t.split($).map((t=>t.split(d)))))}function x(t){const n=[];return t.reduce(((t,e)=>(!1===t||n.push([t,[...e]]),[...e])),!1),n}function A([t,n]){return t.reduce(((t,e)=>[...t,...n.map((t=>[e,t]))]),[])}const I="onExiting",j="onEntering",L="onExited",N="onEntered",C="onSwitching",P="onSwitched",_={[C]:"(ANY)state:changing",[P]:"(ANY)state:changed"};function k(t,n){const e=[],r=[];return{configs:t.reduce(((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=y(i);return n()&&(e.push(...c),r.push(...a)),[...t,...u.map((([t,n])=>({fromState:t,toState:n,action:s})))]}),[]),states:e,routes:r}}function R(t){return s(t)&&"number"==typeof t.__STATEBOT__}const M=p("statebot.");let D=0;function F(){const t=Date.now();function n(t,n){return t.toFixed(n).replace(/\.0+$/,"")}return function(){const e=Date.now()-t;return e<500?`${n(e)} ms`:e<5e3?`${n(e/1e3,2)} s `:e<6e4?`${n(e/1e3,1)} s `:`${n(e/1e3/60,1)} m `}}exports.Statebot=function(c,a){if(!r(c))throw new TypeError("\nStatebot: Please specify a name for this machine");const u=`Statebot[${c}]`;if(!s(a))throw new TypeError(`\n${u}: Please specify options for this machine`);const{chart:f,logLevel:h=3,historyLimit:d=2}=a||{},g=void 0===a.events?i(t()):o(w=a.events)&&e(w.emit)&&(e(w.addListener)||e(w.on))&&(e(w.removeListener)||e(w.off))&&i(a.events);var w;if(!g)throw new TypeError(`\n${u}: Invalid event-emitter specified in options`);const{states:E=[],routes:v=[]}=f?y(f):a,{startIn:T=E[0]}=a;if(!E.includes(T))throw new Error(`${u}: Starting-state not in chart: "${T}"`);const b=p(`${u}#`),S=m(h,console),{canWarn:O}=S,x=[T],A=Math.max(d,2);let R=0;const{pause:M,resume:D,paused:F,Pausable:B}=(function(t,n){n=n||function(){};let e=!!t;return{Pausable:function(t){return(...r)=>e?(n(),!1):t(...r)},paused:()=>e,pause:()=>{e=!0},resume:()=>{e=!1}}})(!1,(()=>S.warn(`${u}: Ignoring callback, paused`))),Y=i(t()),G=B(((t,...n)=>Y.emit(t,...n)));function H(t,n){return Y.on(t,n),()=>Y.off(t,n)}const U=l(c,"states","Listening for the following state-changes",[...E]),V=l(c,"transitions","Listening for the following transitions",[...v]),W=l(c,"events","Listening for the following events");function z(t,o){const i=e(t)?t({enter:Z,emit:X,Enter:ot,Emit:rt}):s(t)?t:null;if(!s(i))throw new TypeError(`Statebot[${c}]#${o}(): Expected an object, or a function that returns an object`);const a=[],u=[],{transitionsForEvents:f,transitionsOnly:l}=(function(t){const o={},i=[];return Object.entries(t).map((([t,c])=>{if(e(c))return void i.push({routeChart:t,action:c});if(!s(c))return;const{on:a,then:u}=c;if(r(a)||n(a)){[a].flat().map((n=>{o[n]=o[n]||[],o[n].push({routeChart:t,action:u})}))}else e(u)&&i.push({routeChart:t,action:c})})),{transitionsForEvents:o,transitionsOnly:i}})(i),p=Object.entries(f).reduce((function(t,[n,e]){const{states:r,routes:o,configs:i}=k(e,O);O()&&(a.push(...r),u.push(...o));return{...t,[n]:i}}),{}),m=k(l,O),h=Object.entries(p).map((function([t,n]){return[W.increase(t),tt(t,((...e)=>{n.map((t=>({...t,args:e}))).some(d)||it(`Event not handled: "${t}"`)}))]})).concat(m.configs.map((function(t){const{fromState:n,toState:e,action:r}=t,o=`${n}->${e}`;return[V.increase(o),H(o,r)]}))).flat();if(O()){a.push(...m.states),u.push(...m.routes);const t=a.filter((t=>!E.includes(t))),n=u.filter((t=>!v.includes(t)));t.length&&S.warn(`Statebot[${c}]#${o}(): Invalid states specified:\n`+t.map((t=>`  > "${t}"`)).join("\n")),n.length&&S.warn(`Statebot[${c}]#${o}(): Invalid transitions specified:\n`+n.map((t=>`  > "${t}"`)).join("\n"))}return()=>h.map((t=>t()));function d({fromState:t,toState:n,action:r,args:o}){return Q(t,(()=>(Z(n,...o),e(r)&&r(...o),!0)))}}function K(){return x[x.length-2]}function q(){return x[x.length-1]}function J(t){const n=void 0!==t?t:q(),e=b("statesAvailableFromHere",{state:r},n);if(e)throw new TypeError(e);return v.reduce(((t,e)=>{const[r,o]=e.split($).map((t=>t.trim()));return r===n?[...t,o]:t}),[])}function Q(t,n,...o){const i=b("inState",{state:r},t);if(i)throw new TypeError(i);const s=q()===t;return void 0===n?s:s?e(n)?n(...o):n:null}const X=B(((t,...n)=>{const e=b("emit",{eventName:r},t);if(e)throw new TypeError(e);return g.emit(t,...n)})),Z=B(((t,...n)=>{const e=b("enter",{state:r},t);if(e)throw new TypeError(e);const o=q(),i=t;if(i===o)return it(`Already in state: "${i}"`),!1;if(!E.includes(i))return it(`Invalid state "${i}", not switching`),!1;const s=`${o}->${i}`;return v.includes(s)?(S.info(`${u}: tId<${++R}>: ${s}`),x.push(i),x.length>A&&x.shift(),G(_[C],i,o,...n),G(s,...n),G(_[P],i,o,...n),!0):(it(`Invalid transition "${s}", not switching`),!1)}));function tt(t,n){const o=b("onEvent",{eventName:r,cb:e},t,n);if(o)throw new TypeError(o);return g.on(t,n),()=>g.off(t,n)}const nt=Object.keys(_).reduce(((t,n)=>({...t,[n]:t=>{const r=b(n,{cb:e},t);if(r)throw new TypeError(r);const o=U.increase(_[n]),i=H(_[n],t);return()=>{i(),o()}}})),{}),et=[[I,C],[j,C],[L,P],[N,P]].reduce(((t,n)=>{const[o,i]=n,s=o.slice(2),c=s.toLowerCase();return{...t,[o]:(t,n)=>{const a=b(o,{state:r,cb:e},t,n);if(a)throw new TypeError(a);const u=[U.increase(t),U.increase(`${t}:${c}`)],f=nt[i](((e,r,...o)=>{0===s.indexOf("Exit")?t===r&&n(e,...o):t===e&&n(r,...o)}));return()=>{f(),u.map((t=>t()))}}}}),{});function rt(t,...n){const e=b("Emit",{eventName:r},t);if(e)throw new TypeError(e);return(...e)=>X(t,...n,...e)}function ot(t,...n){const e=b("Enter",{state:r},t);if(e)throw new TypeError(e);return(...e)=>Z(...[t,n].concat(e))}function it(t){const n=K(),e=q(),r=`${void 0===n?"[undefined]":n}->${e}`,o=J();o.length?S.info(`${u}: ${t}\n  > Previous transition: "${r}"\n  > From "${e}", valid states are: [${o.map((t=>`"${t}"`)).join(", ")}]`):S.info(`${u}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${e}"`)}function st(t){const{description:n,table:e}=t.toValue();S.log(n),e.length?S.table(e):S.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const n=t.flat(),e=b("canTransitionTo",{state:r},n[0]);if(e)throw new TypeError(e);if(!n.length)return!1;const o=J();return n.every((t=>o.includes(t)))},currentState:q,emit:X,Emit:rt,enter:Z,Enter:ot,history:()=>[...x],info:()=>(S.log(`${u}: Information about this state-machine`),st(U),st(V),void st(W)),inspect:()=>({states:U.refs(),transitions:V.refs(),events:W.refs()}),inState:Q,InState:function(t,n,...e){const o=b("InState",{state:r},t);if(o)throw new TypeError(o);return(...r)=>Q(...[t,n].concat(e,r))},name:()=>c,onEntered:et[N],onEntering:et[j],onEvent:tt,onExited:et[L],onExiting:et[I],onSwitched:nt[P],onSwitching:nt[C],onTransitions:t=>z(t,"onTransitions"),pause:M,paused:F,performTransitions:t=>z(t,"performTransitions"),previousState:K,reset:function(){S.warn(`${u}: State-machine reset!`),x.length=0,x.push(T)},resume:D,statesAvailableFromHere:J}},exports.assertRoute=function(t,n,e){const r=M("assertRoute",{machine:R,expectedRoute:c},t,n);if(r)throw TypeError(r);D+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:a=0,timeoutInMs:l=1e3,logLevel:p=3}=e||{},h=m(p),d=`Statebot[${t.name()}]: aId<${D}>`,$=b(n);h.log(`\n${d}: Asserting route: [${$.join(" > ")}]`),h.log(`${d}: > Assertion will start from state: "${i}"`);const g=u(s);let w=()=>{};const E=F();let v,T=F(),y=0,S=!0,O=!1;const x=[...$],A=(function(t,n){n=n||[];const e=[],r=(t=t||[]).map(((t,e)=>n[e]||"center"));let o=!1;function i(){o=!0}function s(...n){if(o)return;const r=t.reduce(((t,e,r)=>({...t,[e]:n[r]||""})),{});e.push(r)}function c(){return e.reduce(((n,e)=>t.map(((t,r)=>Math.max(e[t].length,n[r])))),t.map((()=>0)))}function a(t,n){return t+" ".repeat(n-t.length)}function u(t,n){return" ".repeat(n-t.length)+t}function f(){const n=c();function o(t,e){const o=n[e],i=r[e];return"left"===i?a(t,o):"right"===i?u(t,o):t}return e.reduce(((n,e)=>[...n,t.reduce(((t,n,r)=>({...t,[n]:o(e[n],r)})),{})]),[])}return{lock:i,addRow:s,content:f}})(["state","expected","info","took"],["center","center","left","right"]),I=(function(t){const{revoke:n,fn:e}=f(t);let r;return function(...t){return r=e(...t),n(),r}})((t=>(j("","","","TOTAL: "+E()),A.lock(),h.log(`\n${d}: ${o}: [${t?"FAILED":"SUCCESS"}]`),h.table(A.content()),t))),{addRow:j}=A;return new Promise(((n,e)=>{if(0===x.length)return void e(I(new Error("NO ROUTE TO TEST")));const r=n=>{for(;x.length;){const e=x.shift();j(t.currentState(),`(${e})`,n),O=!1}(t=>{clearTimeout(v),w(),c(),e(t)})(I(new Error(n)))};t.inState(i)&&(S=!1,w=g());const{revoke:o,fn:s}=f((t=>{v=setTimeout((()=>{o(),r("TIMEOUT")}),l),(function(t){if(S)j(t,"-","PENDING");else{const n=x[0];n===t?(j(t,n,O?"REALIGNED":"OKAY",T()),O=!1,x.shift()):(j(t,n,"WRONG STATE",T()),O=!0,y+=1),T=F()}})(t),S&&t===i&&(S=!1,w=g()),y>a&&(o(),r("TOO MANY DEVIATIONS")),x.length<=0&&(o(),((...t)=>{clearTimeout(v),w(),c(),n(...t)})(I()))})),c=t.onSwitching(s)}))},exports.decomposeChart=y,exports.isStatebot=R,exports.routeIsPossible=function(t,n){const e=M("routeIsPossible",{machine:R,route:c},t,n);if(e)throw TypeError(e);const r=b(n);return r.every(((n,e)=>{if(e===r.length-1)return!0;{const o=r[e+1];return t.statesAvailableFromHere(n).includes(o)}}))};
