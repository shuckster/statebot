/*
 * Statebot
 * v2.2.0
 * https://shuckster.github.io/statebot/
 * License: ISC
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=(t=require("events"))&&"object"==typeof t&&"default"in t?t.default:t,n={isArray:r,isEventEmitter:function(t){return s(t)&&o(t.emit)&&o(t.addListener)&&o(t.removeListener)},isFunction:o,isPojo:function(t){if(null===t||!s(t))return!1;return Object.getPrototypeOf(t)===Object.prototype},isString:i,isTemplateLiteral:function(t){if(i(t))return!0;if(r(t))return t.every(t=>i(t));return!1},uniq:function(t){return t.reduce((t,e)=>-1===t.indexOf(e)?[...t,e]:t,[])},Defer:function(t){return(...e)=>(function(t,...e){const n=setTimeout(t,0,...e);return()=>{clearTimeout(n)}})(t,...e)},Once:function(t){const{revoke:e,fn:n}=c(t);let r;return function(...t){return r=n(...t),e(),r}},Revokable:c,ReferenceCounter:function(t,e,n,...r){const o={};function i(t){const e=s(t)-1;o[t]=Math.max(e,0)}function s(t){return o[t]||0}return[...r].flat().forEach(t=>{o[t]=0}),{increase:function(t){return o[t]=s(t)+1,()=>i(t)},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${n}:`,table:Object.keys(o).sort().map(t=>[t,o[t]]).map(([t,n])=>({[e]:t,refs:n||"None"}))}},refs:function(){return{...o}}}},ArgTypeError:function(t=""){return function(e,n,...r){const i=Object.entries(n).map(([t,e])=>({argName:t,argType:e})),s=Object.keys(n).join(", "),c=r.map((t,e)=>{const{argName:n,argType:r}=i[e];if(void 0===t)return`Argument undefined: "${n}"`;let s,c,a;return o(r)?(a=!0===r(t),c=r.name,s=`${c}(${n}) did not return true`):(a=typeof t===r,c=r,s=`Argument "${n}" should be a ${c}`),a?void 0:`${s}: ${n} === ${typeof t}(${t})`}).filter(Boolean);return c.length?`\n${t}${e}(${s}):\n`+c.map(t=>"> "+t).join("\n"):void 0}},Logger:function(t){let e=t;i(e)&&(e={info:3,log:2,warn:1,none:0}[e]||3);function n(){return e>=1}function r(){return e>=2}function o(){return e>=3}return{canWarn:n,canLog:r,canInfo:o,info:(...t)=>o()&&console.info(...t),table:(...t)=>r()&&console.table(...t),log:(...t)=>r()&&console.log(...t),warn:(...t)=>n()&&console.warn(...t),error:(...t)=>console.error(...t)}}};function r(t){return Array.isArray(t)}function o(t){return"function"==typeof t}function i(t){return"string"==typeof t}function s(t){return"object"==typeof t}function c(t){let e,n=!1;return{fn:(...r)=>(n||(e=t(...r)),e),revoke:()=>{n=!0}}}const a=/[\r\n]/,u="|",f="->",l=[u,f].map(t=>t.replace("|","\\|")).join("|"),p=new RegExp(`(${l})$`),h=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,m=/(\/\/[^\n\r]*)/;var d={cxPipe:u,cxArrow:f,rxDisallowedCharacters:h,decomposeChart:function(t){const e=T("decomposeChart",{templateLiteral:$},t);if(e)throw TypeError(e);const n=w(b(t)),r=n.map(S).flat(1).map(v).flat(1),o=[],i=r.map(t=>(o.push(...t),t.join(f))),s=g(i),c=g(o);return{transitions:s.map(t=>t.split(f)),routes:s,states:c}},decomposeRoute:function(t){const e=T("decomposeRoute",{templateLiteral:$},t);if(e)throw TypeError(e);const n=b(t);return w(n).flat(2)}};const{uniq:g,ArgTypeError:E,isTemplateLiteral:$}=n,T=E("statebot.");function b(t){const e=(function(t){return[t].flat().reduce((t,e)=>[...t,e.split(a)],[]).flat()})(t),n=[];return e.reduce((t,e)=>{const r=e.replace(m,"").replace(h,"");return r?p.test(r)?t+r:(n.push(t+r),""):t},""),n}function w(t){return t.map(t=>t.split(f).map(t=>t.split(u)))}function S(t){const e=[];return t.reduce((t,n)=>(!1===t||e.push([t,[...n]]),[...n]),!1),e}function v([t,e]){return t.reduce((t,n)=>[...t,...e.map(t=>[n,t])],[])}var y={Statebot:function(t,n){if(!j(t))throw TypeError("\nStatebot: Please specify a name for this machine");const r=`Statebot[${t}]`;if(!L(n))throw TypeError(`\n${r}: Please specify options for this machine`);const{chart:o,logLevel:i=3,historyLimit:s=2}=n||{},c=I(r+"#"),a=R(i),{canWarn:u}=a,{states:f=[],routes:l=[]}=o?P(o):n,{startIn:p=f[0]}=n;if(!f.includes(p))throw Error(`${r}: Starting-state not in chart: "${p}"`);let h=0;const m=[p],d=Math.max(s,2),g=A(n.events)?n.events:new e,E=new e,$={onSwitching:"(ANY)state:changing",onSwitched:"(ANY)state:changed"};function T(t,...e){return E.emit(t,...e)}function b(t,e){return E.addListener(t,e),function(){E.removeListener(t,e)}}const w=C(t,"states","Listening for the following state-changes",[...f]),S=C(t,"transitions","Listening for the following transitions",[...l]),v=C(t,"events","Listening for the following events");function y(e,n){const r=O(e)?e({enter:q,emit:Y,Enter:V,Emit:U}):L(e)?e:null;if(!L(r))throw TypeError(`Statebot[${t}]#${n}(): Expected an object, or a function that returns an object`);const o={},i=[];Object.entries(r).forEach(([t,e])=>{if(O(e))i.push({routeChart:t,action:e});else if(!L(e))return;const{on:n,then:r}=e;if(j(n)||x(n)){[n].flat().forEach(e=>{o[e]=o[e]||[],o[e].push({routeChart:t,action:r})})}else O(r)&&i.push({routeChart:t,action:e})});const s=[],c=[],p=Object.entries(o).reduce((t,[e,n])=>{const{states:r,routes:o,configs:i}=k(n,u);return u()&&(s.push(...r),c.push(...o)),{...t,[e]:i}},{}),h=[];h.push(...Object.entries(p).map(([t,e])=>[v.increase(t),B(t,(...n)=>{e.some(({fromState:t,toState:e,action:r})=>!!M(t,()=>(q(e,...n),O(r)&&r(...n),!0)))||W(`Event not handled: "${t}"`)})]).flat());const m=k(i,u);if(u()&&(s.push(...m.states),c.push(...m.routes)),h.push(...m.configs.map(t=>{const{fromState:e,toState:n,action:r}=t,o=`${e}->${n}`;return[S.increase(o),b(o,r)]}).flat()),u()){const e=s.filter(t=>!f.includes(t)),r=c.filter(t=>!l.includes(t));e.length&&a.warn(`Statebot[${t}]#${n}(): Invalid states specified:\n`+e.map(t=>`  > "${t}"`).join("\n")),r.length&&a.warn(`Statebot[${t}]#${n}(): Invalid transitions specified:\n`+r.map(t=>`  > "${t}"`).join("\n"))}return()=>h.forEach(t=>t())}function D(){return m[m.length-2]}function _(){return m[m.length-1]}function F(t){const e=void 0!==t?t:_(),n=c("statesAvailableFromHere",{state:j},e);if(n)throw TypeError(n);return l.reduce((t,n)=>{const[r,o]=n.split(N).map(t=>t.trim());return r===e?[...t,o]:t},[])}function M(t,e,...n){const r=c("inState",{state:j},t);if(r)throw TypeError(r);const o=_()===t;return void 0!==e?o?O(e)?e(...n):e:null:o}function Y(t,...e){const n=c("emit",{eventName:j},t);if(n)throw TypeError(n);return g.emit(t,...e)}function q(t,...e){const n=c("enter",{state:j},t);if(n)throw TypeError(n);const o=_(),i=t;if(i===o)return W(`Already in state: "${i}"`),!1;if(!f.includes(i))return W(`Invalid state "${i}", not switching`),!1;const s=`${o}->${i}`;return l.includes(s)?(a.info(`${r}: tId<${++h}>: ${s}`),m.push(i),m.length>d&&m.shift(),T($.onSwitching,i,o,...e),T(s,...e),T($.onSwitched,i,o,...e),!0):(W(`Invalid transition "${s}", not switching`),!1)}function B(t,e){const n=c("onEvent",{eventName:j,cb:O},t,e);if(n)throw TypeError(n);return g.addListener(t,e),()=>g.removeListener(t,e)}const G=Object.keys($).reduce((t,e)=>({...t,[e]:function(t){const n=c(e,{cb:O},t);if(n)throw TypeError(n);const r=w.increase($[e]),o=b($[e],(e,n,...r)=>{t(e,n,...r)});return()=>{o(),r()}}}),{}),H=[["Exiting","onSwitching"],["Entering","onSwitching"],["Exited","onSwitched"],["Entered","onSwitched"]].reduce((t,e)=>{const[n,r]=e,o="on"+n,i=n.toLowerCase();return{...t,[o]:function(t,e){const s=c(o,{state:j,cb:O},t,e);if(s)throw TypeError(s);const a=[w.increase(t),w.increase(`${t}:${i}`)],u=G[r]((r,o,...i)=>{0===n.indexOf("Exit")?t===o&&e(r,...i):t===r&&e(o,...i)});return()=>{u(),a.map(t=>t())}}}},{});function U(t){const e=c("Emit",{eventName:j},t);if(e)throw TypeError(e);return(...e)=>Y(t,...e)}function V(t){const e=c("Enter",{state:j},t);if(e)throw TypeError(e);return(...e)=>q(t,...e)}function W(t){const e=D(),n=_(),o=`${void 0===e?"[undefined]":e}->${n}`,i=F();i.length?a.info(`${r}: ${t}\n  > Previous transition: "${o}"\n  > From "${n}", valid states are: [${i.map(t=>`"${t}"`).join(", ")}]`):a.info(`${r}: ${t}\n  > Previous transition: "${o}"\n  > There are no states available from "${n}"`)}function z(t){const{description:e,table:n}=t.toValue();a.log(e),n.length?a.table(n):a.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const e=t.flat(),n=c("canTransitionTo",{state:j},e[0]);if(n)throw TypeError(n);if(!e.length)return!1;const r=F();return e.every(t=>r.includes(t))},currentState:_,emit:Y,Emit:U,enter:q,Enter:V,history:()=>[...m],info:()=>(a.log(r+": Information about this state-machine"),z(w),z(S),void z(v)),inspect:()=>({states:w.refs(),transitions:S.refs(),events:v.refs()}),inState:M,InState:function(t,e){const n=c("InState",{state:j},t);if(n)throw TypeError(n);return(...n)=>M(t,e,...n)},name:()=>t,onEntered:H.onEntered,onEntering:H.onEntering,onEvent:B,onExited:H.onExited,onExiting:H.onExiting,onSwitched:G.onSwitched,onSwitching:G.onSwitching,onTransitions:t=>y(t,"onTransitions"),performTransitions:t=>y(t,"performTransitions"),previousState:D,reset:function(){a.warn(r+": State-machine reset!"),m.length=0,m.push(p)},statesAvailableFromHere:F}},isStatebot:function(t){return L(t)&&"number"==typeof t.__STATEBOT__}};const{isArray:x,isEventEmitter:A,isFunction:O,isPojo:L,isString:j,ArgTypeError:I,Logger:R,ReferenceCounter:C}=n,{decomposeChart:P,cxArrow:N}=d;function k(t,e){const n=[],r=[];return{configs:t.reduce((t,o)=>{const{routeChart:i,action:s}=o,{states:c,routes:a,transitions:u}=P(i);return e()&&(n.push(...c),r.push(...a)),[...t,...u.map(t=>{const[e,n]=t;return{fromState:e,toState:n,action:s}})]},[]),states:n,routes:r}}var D={routeIsPossible:function(t,e){const n=U("routeIsPossible",{machine:_,expectedRoute:H},t,e);if(n)throw TypeError(n);const r=F(e);return r.every((e,n)=>{if(n===r.length-1)return!0;{const o=r[n+1];return t.statesAvailableFromHere(e).includes(o)}})},assertRoute:function(t,e,n){const r=U("assertRoute",{machine:_,expectedRoute:H},t,e);if(r)throw TypeError(r);V+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:c=0,timeoutInMs:a=1e3,logLevel:u=3}=n||{},f=B(u),l=`Statebot[${t.name()}]: aId<${V}>`,p=F(e);f.log(`\n${l}: Asserting route: [${p.join(" > ")}]`),f.log(`${l}: > Assertion will start from state: "${i}"`);const h=M(s);let m=()=>{};const d=W();let g,E=W(),$=0,T=!0,b=!1;const w=[...p],S=(function(t=[],e=[]){const n=[],r=t.map((t,n)=>e[n]||"center");let o=!1;return{lock:function(){o=!0},addRow:function(...e){if(o)return;const r=t.reduce((t,n,r)=>({...t,[n]:e[r]||""}),{});n.push(r)},content:function(){const e=n.reduce((e,n)=>t.map((t,r)=>Math.max(n[t].length,e[r])),t.map(()=>0));function o(t,n){const o=e[n],i=r[n];return"left"===i?(s=t)+" ".repeat(o-s.length):"right"===i?(function(t,e){return" ".repeat(e-t.length)+t})(t,o):t;var s}return n.reduce((e,n)=>[...e,t.reduce((t,e,r)=>({...t,[e]:o(n[e],r)}),{})],[])}}})(["state","expected","info","took"],["center","center","left","right"]),v=Y(t=>(y("","","","TOTAL: "+d()),S.lock(),f.log(`\n${l}: ${o}: [${t?"FAILED":"SUCCESS"}]`),f.table(S.content()),t)),{addRow:y}=S;return new Promise((e,n)=>{if(0===w.length)return void n(v(new Error("NO ROUTE TO TEST")));const r=e=>{for(;w.length;){const n=w.shift();y(t.currentState(),`(${n})`,e),b=!1}(t=>{clearTimeout(g),m(),u(),n(t)})(v(new Error(e)))};t.inState(i)&&(T=!1,m=h());const{revoke:o,fn:s}=q(t=>{g=setTimeout(()=>{o(),r("TIMEOUT")},a),(function(t){if(T)y(t,"-","PENDING");else{const e=w[0];e===t?(y(t,e,b?"REALIGNED":"OKAY",E()),b=!1,w.shift()):(y(t,e,"WRONG STATE",E()),b=!0,$+=1),E=W()}})(t),T&&t===i&&(T=!1,m=h()),$>c&&(o(),r("TOO MANY DEVIATIONS")),w.length<=0&&(o(),((...t)=>{clearTimeout(g),m(),u(),e(...t)})(v()))}),u=t.onSwitching(s)})}};const{isStatebot:_}=y,{decomposeRoute:F}=d,{Defer:M,Once:Y,Revokable:q,Logger:B,ArgTypeError:G,isTemplateLiteral:H}=n,U=G("statebot.");let V=0;function W(){const t=Date.now();function e(t,e){return t.toFixed(e).replace(/\.0+$/,"")}return function(){const n=Date.now()-t;return n<500?e(n)+" ms":n<5e3?e(n/1e3,2)+" s ":n<6e4?e(n/1e3,1)+" s ":e(n/1e3/60,1)+" m "}}const{Statebot:z,isStatebot:K}=y,{assertRoute:J,routeIsPossible:Q}=D,{decomposeChart:X}=d;var Z={Statebot:z,isStatebot:K,routeIsPossible:Q,assertRoute:J,decomposeChart:X},tt=Z.Statebot,et=Z.isStatebot,nt=Z.routeIsPossible,rt=Z.assertRoute,ot=Z.decomposeChart;exports.Statebot=tt,exports.assertRoute=rt,exports.decomposeChart=ot,exports.default=Z,exports.isStatebot=et,exports.routeIsPossible=nt;
