/*
 * Statebot
 * v2.8.1
 * https://shuckster.github.io/statebot/
 * License: MIT
 */
"use strict";function t(t){return{all:t=t||new Map,on:function(n,e){var r=t.get(n);r?r.push(e):t.set(n,[e])},off:function(n,e){var r=t.get(n);r&&(e?r.splice(r.indexOf(e)>>>0,1):t.set(n,[]))},emit:function(n,e){var r=t.get(n);r&&r.slice().map((function(t){t(e)})),(r=t.get("*"))&&r.slice().map((function(t){t(n,e)}))}}}function n(t){return u(t)&&o(t.emit)&&(o(t.addListener)||o(t.on))&&(o(t.removeListener)||o(t.off))}function e(t){return Array.isArray(t)}function r(t){return"[object Arguments]"===Object.prototype.toString.call(t)}function o(t){return"function"==typeof t}function i(t){return"string"==typeof t}function s(t){return e(t)&&t.every(i)}function a(t){return void 0===t}function c(t){return null===t}function u(t){return"object"==typeof t&&!c(t)}function f(t){return!(c(t)||!u(t)||r(t))&&Object.getPrototypeOf(t)===Object.prototype}function l(t){return!!i(t)||!!e(t)&&t.every(i)}Object.defineProperty(exports,"__esModule",{value:!0}),n.displayName="isEventEmitter",e.displayName="isUnset",e.displayName="isArray",r.displayName="isArguments",o.displayName="isFunction",i.displayName="isString",s.displayName="isAllStrings",a.displayName="isUndefined",c.displayName="isNull",u.displayName="isObject",f.displayName="isPojo",l.displayName="isTemplateLiteral";function p(t){return n=>{const e=Object.entries(n).map((([t,n])=>({argName:t,argType:n})));return s=>(...c)=>{const u=Array.from(c,(t=>r(t)?Array.from(t):t)).flat(1).map((t=>(n,e)=>{if(e>=t.length)return;const{argName:r,argType:s}=t[e];if(a(n))return`Argument undefined: "${r}"`;const c=Array.isArray(s)?s:[s],u=c.map((t=>o(t)?((t,n,e)=>n(e)?void 0:(n.displayName||n.name)+`(${t}) did not return true`)(r,t,n):((t,n,e)=>typeof e===n?void 0:`Argument "${t}" should be a ${n}`)(r,t,n))).filter(i);return(c.length>1?u.length>1:u.length)?u.join("\n| ")+`\n> typeof ${r} === ${typeof n}(${JSON.stringify(n)})`:void 0})(e)).filter(i);if(!u.length)return;const f=Object.keys(n).join(", ");return`\n${t||""}${s}(${f}):\n${u.map((t=>`| ${t}`)).join("\n")}`}}}function m(t){const n=t.addListener?(...n)=>t.addListener(...n):(...n)=>t.on(...n),e=t.removeListener?(...n)=>t.removeListener(...n):(...n)=>t.off(...n),r=new Map;return{emit:(n,...e)=>t.emit(n,e),on:function(t,e){let o=r.get(e);o||(o={handleEvent:(t=[])=>e(...[t].flat()),refCount:0},r.set(e,o)),o.refCount+=1,n(t,o.handleEvent)},off:function(t,n){let o=r.get(n);o&&(e(t,o.handleEvent),o.refCount-=1,0===o.refCount&&r.delete(n))}}}function d(t){return t.reduce(((t,n)=>-1===t.indexOf(n)?(t.push(n),t):t),[])}function h(t){return(...n)=>(function(t,...n){const e=setTimeout(t,0,...n);return()=>{clearTimeout(e)}})(t,...n)}function g(t){const{revoke:n,fn:e}=$(t);let r;return function(...t){return r=e(...t),n(),r}}function $(t){let n,e=!1;return{fn:(...r)=>(e||(n=t(...r)),n),revoke:()=>{e=!0}}}function w(t,n,e,...r){const o=[...r].flat().reduce(((t,n)=>({...t,[n]:0})),{});function i(t){const n=s(t)-1;o[t]=Math.max(n,0)}function s(t){return o[t]||0}return{increase:function(t){return o[t]=s(t)+1,()=>{i(t)}},decrease:i,countOf:s,toValue:function(){return{description:`Statebot[${t}]: ${e}:`,table:Object.keys(o).sort().map((t=>[t,o[t]])).map((([t,e])=>({[n]:t,refs:e||"None"})))}},refs:function(){return{...o}}}}function y(t,n){function e(){return t>=1}function r(){return t>=2}function o(){return t>=3}i(t)&&(t={info:3,log:2,warn:1,none:0}[t]||3);const{info:s,table:a,log:c,warn:u,error:f}=n||console;return{canWarn:e,canLog:r,canInfo:o,info:(...t)=>{o()&&s(...t)},table:(...t)=>{r()&&a(...t)},log:(...t)=>{r()&&c(...t)},warn:(...t)=>{e()&&u(...t)},error:(...t)=>{f(...t)}}}const E=/[\r\n]/,T="|",v="->",b=[T,v].map((t=>t.replace("|","\\|"))).join("|"),S=new RegExp(`(${b})$`),O=/[^a-z0-9!@#$%^&*:_+=<>|~.\x2D]/gi,N=/(\/\/[^\n\r]*)/,j=p("statebot.");function A(t){const n=j({templateLiteral:l})("decomposeRoute")(t);if(n)throw TypeError(n);return L(I(t)).flat(2)}function x(t){const n=j({chart:l})("decomposeChart")(t);if(n)throw TypeError(n);const e=L(I(t)),r=e.flatMap(k).flatMap(C);let o=!1;const i=d(r.map((t=>(t.includes("")&&(o=!0),t.join(v))))),s=d(e.flat(3));return{transitions:i.map((t=>t.split(v))),routes:i,states:o?s:s.filter(Boolean)}}function I(t){const n=(function(t){return[t].flat().reduce(((t,n)=>[...t,...n.split(E)]),[])})(t),e=[];let r=!1;const o=n.reduce(((t,n)=>{const o=n.replace(N,"").replace(O,"");return o?(r=S.test(o),r?t+o:(e.push(t+o),"")):t}),"");return r||o?[...e,o]:[...e]}function L(t){return t.map((t=>t.split(v).map((t=>t.split(T)))))}function k(t){const n=[];return t.reduce(((t,e)=>(!1===t||n.push([t,[...e]]),[...e])),!1),n}function C([t,n]){return t.reduce(((t,e)=>(t.push(...n.map((t=>[e,t]))),t)),[])}const P="onExiting",M="onEntering",R="onExited",_="onEntered",F="onSwitching",D="onSwitched",U={[F]:"(ANY)state:changing",[D]:"(ANY)state:changed"};function W(t,n){const e=[],r=[];return{configs:t.reduce(((t,o)=>{const{routeChart:i,action:s}=o,{states:a,routes:c,transitions:u}=x(i);return n()&&(e.push(...a),r.push(...c)),[...t,...u.map((([t,n])=>({fromState:t,toState:n,action:s})))]}),[]),states:e,routes:r}}function Y(t){return f(t)&&"number"==typeof t.__STATEBOT__}const B=p("statebot.");let G=0;function H(){const t=Date.now();function n(t,n){return t.toFixed(n).replace(/\.0+$/,"")}return function(){const e=Date.now()-t;return e<500?`${n(e)} ms`:e<5e3?`${n(e/1e3,2)} s `:e<6e4?`${n(e/1e3,1)} s `:`${n(e/1e3/60,1)} m `}}exports.Statebot=function(r,c){if(!i(r))throw new TypeError("\nStatebot: Please specify a name for this machine");const u=`Statebot[${r}]`;if(!f(c))throw new TypeError(`\n${u}: Please specify options for this machine`);const{chart:l,logLevel:d=3,historyLimit:h=2}=c||{},$=a(c.events)?m(t()):n(c.events)&&m(c.events);if(!$)throw new TypeError(`\n${u}: Invalid event-emitter specified in options`);const{states:E=[],routes:T=[]}=l?x(l):c,{startIn:b=E[0]}=c;if(!E.includes(b))throw new Error(`${u}: Starting-state not in chart: "${b}"`);const S=p(`${u}#`),O=y(d,console),{canWarn:N}=O,j=[b],A=Math.max(h,2);let I=0;const{pause:L,resume:k,paused:C,Pausable:Y}=(function(t,n){n=n||function(){};let e=!!t;return{Pausable:function(t){return(...r)=>e?(n(),!1):t(...r)},paused:()=>e,pause:()=>{e=!0},resume:()=>{e=!1}}})(!1,(()=>O.warn(`${u}: Ignoring callback, paused`))),B=(function(){const t={};function n(n,e){t[n]=(t[n]||[]).filter((t=>t!==e)),0===t[n].length&&delete t[n]}return{define:function(e,r){return t[e]=t[e]||[],t[e].push(r),()=>n(e,r)},undefine:n,definitionsOf:function(n){return t[n]||[]}}})(),G=m(t()),H=Y(G.emit);function V(t,n){return G.on(t,n),()=>G.off(t,n)}const z=w(r,"states","Listening for the following state-changes",[...E]),J=w(r,"transitions","Listening for the following transitions",[...T]),K=w(r,"events","Listening for the following events");function q(t,n){const s=o(t)?t({enter:ot,emit:rt,Enter:ut,Emit:ct}):f(t)?t:null;if(!f(s))throw new TypeError(`Statebot[${r}]#${n}(): Expected an object, or a function that returns an object`);const a=[],c=[],{transitionsForEvents:u,transitionsOnly:l}=(function(t){const n={},r=[];return Object.entries(t).map((([t,s])=>{if(o(s))return void r.push({routeChart:t,action:s});if(!f(s))return;const{on:a,then:c}=s;if(i(a)||e(a)){[a].flat().map((e=>{n[e]=n[e]||[],n[e].push({routeChart:t,action:c})}))}else o(c)&&r.push({routeChart:t,action:s})})),{transitionsForEvents:n,transitionsOnly:r}})(s),p=Object.entries(u).reduce((function(t,[n,e]){const{states:r,routes:o,configs:i}=W(e,N);N()&&(a.push(...r),c.push(...o));return{...t,[n]:i}}),{}),m=W(l,N),d=Object.entries(p).map((function([t,n]){return[K.increase(t),it(t,((...e)=>{n.map((t=>({...t,args:e}))).some(h)||ft(`Event not handled: "${t}"`)}))].concat(n.map((({fromState:n,toState:e})=>B.define(`${t}:${n}`,e))))})).concat(m.configs.map((function(t){const{fromState:n,toState:e,action:r}=t,o=`${n}->${e}`;return[J.increase(o),V(o,(i=e,s=r,(...t)=>$(i,s,...t)))];var i,s}))).flat();if(N()){a.push(...m.states),c.push(...m.routes);const t=a.filter((t=>!E.includes(t))),e=c.filter((t=>!T.includes(t)));t.length&&O.warn(`Statebot[${r}]#${n}(): Invalid states specified:\n`+t.map((t=>`  > "${t}"`)).join("\n")),e.length&&O.warn(`Statebot[${r}]#${n}(): Invalid transitions specified:\n`+e.map((t=>`  > "${t}"`)).join("\n"))}return()=>d.map((t=>t()));function h({fromState:t,toState:n,action:e,args:r}){return et(t,(()=>(ot(n,...r),o(e)&&$(n,e,...r),!0)))}function $(t,n,...e){const r=n(...e);if(o(r)){const n=g(at[P](t,(t=>{n(),r(t)})));d.push(n)}}}function Q(t,n,e=!0){const r=S({eventName:i})("peek")(t);if(r)throw new TypeError(r);const s=t+":"+Z(),c=B.definitionsOf(s);if(c.length>1){const n=`${u}: Event "${t}" causes multiple transitions.\n  > From state: "${Z()}"\n  > To states: "${c.join(", ")}"\n\nCheck your performTransitions() config.`;throw new RangeError(n)}e||0!==c.length||(0===K.countOf(t)?O.warn(`${u}: Event not handled: "${t}"`):O.warn(`${u}: Will not transition after emitting: "${t}"`));const l=c[0];if(a(n))return l??Z();const p=S({stateObject:f})("peek")(n);if(p)throw new TypeError(p);if(Object.prototype.hasOwnProperty.call(n,l)){const t=n[l];return o(t)?t():t}return null}function X(){return j[j.length-2]}function Z(){return j[j.length-1]}function tt(t){const n=a(t)?Z():t,e=S({state:i})("statesAvailableFromHere")(n);if(e)throw new TypeError(e);return T.reduce(((t,e)=>{const[r,o]=e.split(v).map((t=>t.trim()));return r===n?[...t,o]:t}),[])}function nt(t,n,...e){const r=Z()===t;return a(n)?r:r?o(n)?n(...e):n:null}function et(...t){const n=S({state:[i,f]})("inState")(t[0]);if(n)throw new TypeError(n);return f(t[0])?(function(t,...n){const e=Object.entries(t).find((([t])=>nt(t)));return e?nt(...e.concat(n)):null})(...t):nt(...t)}const rt=Y(((t,...n)=>{const e=S({eventName:i})("emit")(t);if(e)throw new TypeError(e);return Q(t),$.emit(t,...n)})),ot=Y(((t,...n)=>{const e=S({state:i})("enter")(t);if(e)throw new TypeError(e);const r=Z(),o=t;if(o===r)return ft(`Already in state: "${o}"`),!1;if(!E.includes(o))return ft(`Invalid state "${o}", not switching`),!1;const s=`${r}->${o}`;return T.includes(s)?(O.info(`${u}: tId<${++I}>: ${s}`),j.push(o),j.length>A&&j.shift(),H(U[F],o,r,...n),H(s,...n),H(U[D],o,r,...n),!0):(ft(`Invalid transition "${s}", not switching`),!1)}));function it(t,n){const e=S({eventName:i,cb:o})("onEvent")(t,n);if(e)throw new TypeError(e);return $.on(t,n),()=>$.off(t,n)}const st=Object.keys(U).reduce(((t,n)=>({...t,[n]:t=>{const e=S({cb:o})(n)(t);if(e)throw new TypeError(e);const r=z.increase(U[n]),i=V(U[n],t);return()=>{i(),r()}}})),{}),at=[[P,F],[M,F],[R,D],[_,D]].reduce(((t,n)=>{const[e,r]=n,s=e.slice(2),a=s.toLowerCase();return{...t,[e]:(t,n)=>{const c=S({state:i,cb:o})(e)(t,n);if(c)throw new TypeError(c);const u=[z.increase(t),z.increase(`${t}:${a}`)],f=st[r](((e,r,...o)=>{0===s.indexOf("Exit")?t===r&&n(e,...o):t===e&&n(r,...o)}));return()=>{f(),u.map((t=>t()))}}}}),{});function ct(t,...n){const e=S({eventName:i})("Emit")(t);if(e)throw new TypeError(e);return(...e)=>rt(t,...n,...e)}function ut(t,...n){const e=S({state:i})("Enter")(t);if(e)throw new TypeError(e);return(...e)=>ot(t,...n,...e)}function ft(t){const n=X(),e=Z(),r=`${a(n)?"[undefined]":n}->${e}`,o=tt();o.length?O.info(`${u}: ${t}\n  > Previous transition: "${r}"\n  > From "${e}", valid states are: [${o.map((t=>`"${t}"`)).join(", ")}]`):O.info(`${u}: ${t}\n  > Previous transition: "${r}"\n  > There are no states available from "${e}"`)}function lt(t){const{description:n,table:e}=t.toValue();O.log(n),e.length?O.table(e):O.log("  > No information")}return{__STATEBOT__:1,canTransitionTo:function(...t){const n=t.flat();if(2===n.length&&i(n[0])&&f(n[1])){const t=n[0],{afterEmitting:e}=n[1],r=S({thisState:i,"{ afterEmitting }":i})("canTransitionTo")(t,e);if(r)throw new TypeError(r);return t!==Z()&&Q(e)===t}return(function(...t){const n=S({states:s})("canTransitionTo")([t]);if(n)throw new TypeError(n);if(!t.length)return!1;const e=tt();return t.every((t=>e.includes(t)))})(...n)},currentState:Z,emit:rt,Emit:ct,enter:ot,Enter:ut,history:()=>[...j],info:()=>(O.log(`${u}: Information about this state-machine`),lt(z),lt(J),void lt(K)),inspect:()=>({states:z.refs(),transitions:J.refs(),events:K.refs()}),inState:et,InState:function(...t){const n=S({state:[i,f]})("InState")(t[0]);if(n)throw new TypeError(n);return f(t[0])?(function(t,...n){return(...e)=>et(t,...n,...e)})(...t):(function(t,n,...e){return(...r)=>et(t,n,...e,...r)})(...t)},name:()=>r,onEntered:at[_],onEntering:at[M],onEvent:it,onExited:at[R],onExiting:at[P],onSwitched:st[D],onSwitching:st[F],onTransitions:t=>q(t,"onTransitions"),pause:L,paused:C,peek:function(t,n){return Q(t,n,!1)},performTransitions:t=>q(t,"performTransitions"),previousState:X,reset:function(){O.warn(`${u}: State-machine reset!`),j.length=0,j.push(b)},resume:k,statesAvailableFromHere:tt}},exports.assertRoute=function(t,n,e){const r=B({machine:Y,expectedRoute:l})("assertRoute")(t,n);if(r)throw TypeError(r);G+=1;const{description:o="Assertion complete",fromState:i="",run:s=(()=>{}),permittedDeviations:a=0,timeoutInMs:c=1e3,logLevel:u=3}=e||{},f=y(u),p=`Statebot[${t.name()}]: aId<${G}>`,m=A(n);f.log(`\n${p}: Asserting route: [${m.join(" > ")}]`),f.log(`${p}: > Assertion will start from state: "${i}"`);const d=h(s);let w=()=>{};const E=H();let T,v=H(),b=0,S=!0,O=!1;const N=[...m],j=(function(t,n){n=n||[];const e=[],r=(t=t||[]).map(((t,e)=>n[e]||"center"));let o=!1;function i(){o=!0}function s(...n){if(o)return;const r=t.reduce(((t,e,r)=>({...t,[e]:n[r]||""})),{});e.push(r)}function a(){return e.reduce(((n,e)=>t.map(((t,r)=>Math.max(e[t].length,n[r])))),t.map((()=>0)))}function c(){const n=a();function o(t,e){const o=n[e],i=r[e];return"left"===i?t.padEnd(o):"right"===i?t.padStart(o):t}return e.reduce(((n,e)=>{const r=t.reduce(((t,n,r)=>({...t,[n]:o(e[n],r)})),{});return[...n,r]}),[])}return{lock:i,addRow:s,content:c}})(["state","expected","info","took"],["center","center","left","right"]),x=g((t=>(I("","","","TOTAL: "+E()),j.lock(),f.log(`\n${p}: ${o}: [${t?"FAILED":"SUCCESS"}]`),f.table(j.content()),t))),{addRow:I}=j;return new Promise(((n,e)=>{if(0===N.length)return void e(x(new Error("NO ROUTE TO TEST")));const r=n=>{for(;N.length;){const e=N.shift();I(t.currentState(),`(${e})`,n),O=!1}(t=>{clearTimeout(T),w(),u(),e(t)})(x(new Error(n)))};t.inState(i)&&(S=!1,w=d());const{revoke:o,fn:s}=$((t=>{T=setTimeout((()=>{o(),r("TIMEOUT")}),c),(function(t){if(S)I(t,"-","PENDING");else{const n=N[0];n===t?(I(t,n,O?"REALIGNED":"OKAY",v()),O=!1,N.shift()):(I(t,n,"WRONG STATE",v()),O=!0,b+=1),v=H()}})(t),S&&t===i&&(S=!1,w=d()),b>a&&(o(),r("TOO MANY DEVIATIONS")),N.length<=0&&(o(),((...t)=>{clearTimeout(T),w(),u(),n(...t)})(x()))})),u=t.onSwitching(s)}))},exports.decomposeChart=x,exports.isStatebot=Y,exports.routeIsPossible=function(t,n){const e=B({machine:Y,route:l})("routeIsPossible")(t,n);if(e)throw TypeError(e);const r=A(n);return r.every(((n,e)=>{if(e===r.length-1)return!0;{const o=r[e+1];return t.statesAvailableFromHere(n).includes(o)}}))};
